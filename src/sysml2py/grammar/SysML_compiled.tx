RootNamespace:
	 PackageBodyElement*
;

Identification:
	  '<' declaredShortName = Name '>' ( declaredName = Name )?
	| declaredName = Name
;

RelationshipBody:
	';' | '{' ( ownedRelationship += OwnedAnnotation )* '}'
;

Dependency:
	( ownedRelationship += PrefixMetadataAnnotation )*
	'dependency' ( Identification? 'from' )?
    client += QualifiedName ( ',' client += QualifiedName )* 'to'
    supplier += QualifiedName ( ',' supplier += QualifiedName )*
    RelationshipBody
;

Annotation:
	annotatedElement = QualifiedName
;

OwnedAnnotation:
	ownedRelatedElement += AnnotatingElement
;

AnnotatingMember:
	ownedRelatedElement += AnnotatingElement
;

AnnotatingElement:
	  ownedRelatedElement = CommentSysML
	| ownedRelatedElement = Documentation
	| ownedRelatedElement = TextualRepresentation
	| ownedRelatedElement = MetadataUsage
;

CommentSysML:
	( 'comment' identification=Identification?
	  ('about' ownedRelationship += Annotation
	     ( ',' ownedRelationship += Annotation )* )?
	)?
	body = REGULAR_COMMENT
;

Documentation:
	'doc' identification=Identification? body=REGULAR_COMMENT
;

TextualRepresentation:
    ( 'rep' Identification? )?
    'language' language = STRING_VALUE
    body = REGULAR_COMMENT
;

MetadataKeyword:
	'metadata'
;

MetadataDefKeyword:
	MetadataKeyword 'def'
;

MetadataUsageKeyword:
	MetadataKeyword | '@'
;

MetadataDefinition:
	( isAbstract ?= 'abstract')? MetadataDefKeyword
	Definition
;

PrefixMetadataAnnotation:
	'#' ownedRelatedElement += PrefixMetadataUsage
;

PrefixMetadataMember:
	'#' ownedRelatedElement += PrefixMetadataUsage
;

PrefixMetadataUsage:
	ownedRelationship += MetadataTyping
;

MetadataUsage:
	MetadataUsageKeyword MetadataUsageDeclaration
	( 'about' ownedRelationship += Annotation
		( ',' ownedRelationship += Annotation )*
	)?
	MetadataBody
;

MetadataUsageDeclaration:
	( Identification? DefinedByKeyword )? ownedRelationship += MetadataTyping
;

MetadataTyping:
	type = QualifiedName
;

MetadataBody:
	  ';'
	| '{' ( ownedRelationship += DefinitionMember
		  | ownedRelationship += MetadataBodyUsageMember
		  | ownedRelationship += AliasMember
		  | ownedRelationship += Import
	      )*
	  '}'
;

MetadataBodyUsageMember:
	ownedRelatedElement += MetadataBodyUsage
;

MetadataBodyUsage:
	'ref'? ( ':>>' | 'redefines' )? ownedRelationship += OwnedRedefinition
	FeatureSpecializationPart? ValuePart?
	body=MetadataBody
;

Package:
	( ownedRelationship += PrefixMetadataMember )*
	declaration=PackageDeclaration body=PackageBody
;

LibraryPackage:
	( isStandard ?= 'standard' )? 'library'
	( ownedRelationship += PrefixMetadataMember )*
	PackageDeclaration PackageBody
;

PackageDeclaration:
	'package' identification = Identification?
;

PackageBody:
	 ';'
	| '{' ( 					    ownedRelationship += PackageMember
		  | ownedRelationship += ElementFilterMember
		  | ownedRelationship += AliasMember
		  | ownedRelationship += Import )*
	  '}'
;

PackageBodyElement:
	  ownedRelationship += PackageMember
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

MemberPrefix:
    ( visibility = VisibilityIndicator )?
;

PackageMember:
	prefix = MemberPrefix
	( ownedRelatedElement = DefinitionElement | ownedRelatedElement = UsageElement)
;

ElementFilterMember:
	prefix = MemberPrefix
	'filter' ownedRelatedElement += OwnedExpression ';'
;

AliasMember:
	prefix = MemberPrefix
	'alias' ( '<' memberShortName = Name '>' )? ( memberName = Name )?
	'for' memberElement = QualifiedName
	body = RelationshipBody
;

ImportPrefix:
	( visibility = VisibilityIndicator )?
	'import' ( isImportAll ?= 'all' )?
;

Import:
	(ownedRelationship = NamespaceImport | ownedRelationship = MembershipImport)
	body = RelationshipBody
;

NamespaceImport:
	prefix = ImportPrefix
	( namespace = ImportedNamespace | ownedRelatedElement += FilterPackage )
;

MembershipImport:
	prefix = ImportPrefix membership=ImportedMembership
;

ImportedNamespace:
    namespace = QualifiedName  !'::**' '::*'
;

ImportedMembership:
	importedMembership = QualifiedName ( '::' isRecursive ?= '**' )?
;

FilterPackage:
	ownedRelationship += FilterPackageImport
	( ownedRelationship += FilterPackageMember )+
;

FilterPackageImport:
	 FilterPackageMembershipImport | FilterPackageNamespaceImport
;

FilterPackageMembershipImport:
	ImportedMembership
;

FilterPackageNamespaceImport:
	ImportedNamespace
;

FilterPackageMember:
	visibility = FilterPackageMemberVisibility ownedRelatedElement += OwnedExpression ']'
;

FilterPackageMemberVisibility:
	private = '['
;

VisibilityIndicator:
	public = 'public' | private = 'private'| protected = 'protected'
;

DefinitionElement:
	  ownedRelatedElement = Package
	| ownedRelatedElement = LibraryPackage
	| ownedRelatedElement = AnnotatingElement
	| ownedRelatedElement = Dependency
	| ownedRelatedElement = AttributeDefinition
	| ownedRelatedElement = EnumerationDefinition
	| ownedRelatedElement = OccurrenceDefinition
	| ownedRelatedElement = IndividualDefinition
	| ownedRelatedElement = ItemDefinition
	| ownedRelatedElement = MetadataDefinition
	| ownedRelatedElement = PartDefinition
	| ownedRelatedElement = ConnectionDefinition
	| ownedRelatedElement = FlowConnectionDefinition
	| ownedRelatedElement = InterfaceDefinition
	| ownedRelatedElement = AllocationDefinition
	| ownedRelatedElement = PortDefinition
	| ownedRelatedElement = ActionDefinition
	| ownedRelatedElement = CalculationDefinition
	| ownedRelatedElement = StateDefinition
	| ownedRelatedElement = ConstraintDefinition
	| ownedRelatedElement = RequirementDefinition
	| ownedRelatedElement = ConcernDefinition
	| ownedRelatedElement = CaseDefinition
	| ownedRelatedElement = AnalysisCaseDefinition
	| ownedRelatedElement = VerificationCaseDefinition
	| ownedRelatedElement = UseCaseDefinition
	| ownedRelatedElement = ViewDefinition
	| ownedRelatedElement = ViewpointDefinition
	| ownedRelatedElement = RenderingDefinition
	| ownedRelatedElement = ExtendedDefinition
;

UsageElement:
	  ownedRelatedElement = NonOccurrenceUsageElement
	| ownedRelatedElement = OccurrenceUsageElement
;

SubclassificationPart:
	SpecializesKeyword ownedRelationship += OwnedSubclassification
	( ',' ownedRelationship += OwnedSubclassification )*
;

SpecializesKeyword:
	':>' | 'specializes'
;

OwnedSubclassification:
	superclassifier = QualifiedName
;

FeatureDeclaration:
	  identification=Identification specialization=FeatureSpecializationPart?
	| specialization=FeatureSpecializationPart
;

FeatureSpecializationPart:
	  ( specialization+=FeatureSpecialization )+ multiplicity=MultiplicityPart? specialization2+=FeatureSpecialization*
	| multiplicity2=MultiplicityPart specialization+=FeatureSpecialization*
;

MultiplicityPart:
	  ownedRelationship += OwnedMultiplicity
	| ( ownedRelationship += OwnedMultiplicity )?

( isOrdered ?= 'ordered' isNonunique ?= 'nonunique'
   | isNonunique2 ?= 'nonunique' isOrdered2 ?= 'ordered'
)

;

FeatureSpecialization:
	ownedRelationship=Typings | ownedRelationship=Subsettings | ownedRelationship=References | ownedRelationship=Redefinitions
;

Typings:
	typedby=TypedBy ( ',' ownedRelationship += FeatureTyping )*
;

TypedBy:
	DefinedByKeyword ownedRelationship += FeatureTyping
;

DefinedByKeyword:
	':' | 'defined' 'by'
;

Subsettings:
	SubsetsKeyword ownedRelationship += OwnedSubsetting[',']
;

SubsetsKeyword:
	':>' | 'subsets'
;

References:
	ReferencesKeyword ownedRelationship += OwnedReferenceSubsetting
;

ReferencesKeyword:
	'::>' | 'references'
;

Redefinitions:
 redefines=RedefinesKeyword ownedRelationship += OwnedRedefinition[',']
;

RedefinesKeyword:
	':>>' | 'redefines'
;

FeatureTyping:
	ownedRelationship = OwnedFeatureTyping | ownedRelationship = ConjugatedPortTyping
;

OwnedSubsetting:
	  ownedRelatedElement += OwnedFeatureChain
	| subsettedFeature = QualifiedName
;

OwnedReferenceSubsetting:
	  ownedRelatedElement += OwnedFeatureChain
	| referencedFeature = QualifiedName
  
;

OwnedRedefinition:
  redefinedFeature = QualifiedName
  | ownedRelatedElement += OwnedFeatureChain
;

OwnedMultiplicity:
	ownedRelatedElement += MultiplicityRange
;

MultiplicityRange:
		'[' ownedRelationship += MultiplicityExpressionMember
	      ( '..' ownedRelationship += MultiplicityExpressionMember )? ']'
;

MultiplicityRelatedElement:
    (ownedRelatedElement = LiteralExpression | ownedRelatedElement = FeatureReferenceExpression)
;

MultiplicityExpressionMember:
    ownedRelatedElement += MultiplicityRelatedElement
;

BasicDefinitionPrefix:
	isAbstract ?= 'abstract' | isVariation ?= 'variation'
;

DefinitionExtensionKeyword:
	ownedRelationship += PrefixMetadataMember
;

DefinitionPrefix:
	prefix=BasicDefinitionPrefix? keyword+=DefinitionExtensionKeyword*
;

Definition:
	declaration=DefinitionDeclaration body=DefinitionBody
;

DefinitionDeclaration:
	identification=Identification? subclassificationpart=SubclassificationPart?
;

DefinitionBody:
	';' | '{' ownedRelatedElement+=DefinitionBodyItem* '}'
;

DefinitionBodyItem:
	  ownedRelationship += DefinitionMember
	| ownedRelationship += VariantUsageMember
	| ownedRelationship += NonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
	  ownedRelationship += OccurrenceUsageMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

DefinitionMember:
	prefix = MemberPrefix
	ownedRelatedElement += DefinitionElement
;

VariantUsageMember:
	MemberPrefix 'variant'
	ownedRelatedElement += VariantUsageElement
;

NonOccurrenceUsageMember:
	prefix=MemberPrefix ownedRelatedElement += NonOccurrenceUsageElement
;

OccurrenceUsageMember:
	prefix=MemberPrefix ownedRelatedElement += OccurrenceUsageElement
;

StructureUsageMember:
	prefix=MemberPrefix ownedRelatedElement += StructureUsageElement
;

BehaviorUsageMember:
	prefix=MemberPrefix ownedRelatedElement = BehaviorUsageElement
;

FeatureDirection:
	in = 'in ' | out = 'out' | inout = 'inout'
;

RefPrefix:
	( direction = FeatureDirection )?
	( isAbstract ?= 'abstract' | isVariation ?= 'variation')?
	( isReadOnly ?= 'readonly' )?
	( isDerived ?= 'derived' )?
	( isEnd ?= 'end' )?
;

BasicUsagePrefix:
	prefix=RefPrefix
	( isReference ?= 'ref' )?
;

UsageExtensionKeyword:
	ownedRelationship += PrefixMetadataMember
;

UsagePrefix:
	prefix=BasicUsagePrefix usageKeyword += UsageExtensionKeyword*
;

Usage:
	declaration=UsageDeclaration? completion=UsageCompletion
;

UsageDeclaration:
	  declaration=FeatureDeclaration
;

UsageCompletion:
	valuepart=ValuePart? body=UsageBody
;

UsageBody:
	body=DefinitionBody
;

ValuePart:
	  ownedRelationship += FeatureValue
	| ownedRelationship += FeatureValueExpression
	  ownedRelationship += EmptyAssignmentActionMember
;

FeatureValue:
	( '=' | isDefault ?= 'default' ( isEqual ?= '=' | isInitial ?= ':=' )? )
	ownedRelatedElement = OwnedExpression
;

FeatureValueExpression:
	isInitial ?= ':='
	ownedRelatedElement += OwnedExpression
;

EmptyAssignmentActionMember:
	ownedRelatedElement += EmptyAssignmentAction
;

EmptyAssignmentAction:
	ownedRelationship += EmptyTargetMember
	ownedRelationship += EmptyParameterMember
;

EmptyTargetMember:
	ownedRelatedElement += EmptyTargetParameter
;

EmptyTargetParameter:
	ownedRelationship += TargetFeatureMember
;

ReferenceKeyword:
	'ref'
;

ReferenceUsageKeyword:
	ReferenceKeyword
;

DefaultReferenceUsage:
	prefix=RefPrefix declaration=UsageDeclaration valuepart=ValuePart? body=UsageBody
;

ReferenceUsage:
	prefix=RefPrefix ReferenceUsageKeyword usage=Usage
;

VariantReference:
	ownedRelationship += OwnedReferenceSubsetting
	FeatureSpecialization* UsageBody
;

NonOccurrenceUsageElement:
	  ownedRelatedElement = DefaultReferenceUsage
	| ownedRelatedElement = ReferenceUsage
	| ownedRelatedElement = AttributeUsage
	| ownedRelatedElement = EnumerationUsage
	| ownedRelatedElement = BindingConnector
	| ownedRelatedElement = Succession
	| ownedRelatedElement = ExtendedUsage
;

OccurrenceUsageElement:
	ownedRelatedElement = StructureUsageElement | ownedRelatedElement = BehaviorUsageElement
;

StructureUsageElement:
	  ownedRelatedElement = OccurrenceUsage
	| ownedRelatedElement = IndividualUsage
	| ownedRelatedElement = PortionUsage
	| ownedRelatedElement = EventOccurrenceUsage
	| ownedRelatedElement = ItemUsage
	| ownedRelatedElement = PartUsage
	| ownedRelatedElement = ViewUsage
	| ownedRelatedElement = RenderingUsage
	| ownedRelatedElement = PortUsage
	| ownedRelatedElement = ConnectionUsage
	| ownedRelatedElement = InterfaceUsage
	| ownedRelatedElement = AllocationUsage
	| ownedRelatedElement = Message
	| ownedRelatedElement = FlowConnectionUsage
	| ownedRelatedElement = SuccessionFlowConnectionUsage
;

BehaviorUsageElement:
	  ownedRelationship = ActionUsage
	| ownedRelationship = CalculationUsage
	| ownedRelationship = StateUsage
	| ownedRelationship = ConstraintUsage
	| ownedRelationship = RequirementUsage
	| ownedRelationship = ConcernUsage
	| ownedRelationship = CaseUsage
	| ownedRelationship = AnalysisCaseUsage
	| ownedRelationship = VerificationCaseUsage
	| ownedRelationship = UseCaseUsage
	| ownedRelationship = ViewpointUsage
	| ownedRelationship = PerformActionUsage
	| ownedRelationship = ExhibitStateUsage
	| ownedRelationship = IncludeUseCaseUsage
	| ownedRelationship = AssertConstraintUsage
	| ownedRelationship = SatisfyRequirementUsage
;

VariantUsageElement:
	  VariantReference
	| ReferenceUsage
	| AttributeUsage
	| BindingConnector
	| Succession
	| OccurrenceUsage
	| IndividualUsage
	| PortionUsage
	| EventOccurrenceUsage
	| ItemUsage
	| PartUsage
	| ViewUsage
	| RenderingUsage
	| PortUsage
	| ConnectionUsage
	| InterfaceUsage
	| AllocationUsage
	| Message
	| FlowConnectionUsage
	| SuccessionFlowConnectionUsage
	| BehaviorUsageElement
;

ExtendedDefinition:
	BasicDefinitionPrefix? DefinitionExtensionKeyword+ 'def' Definition
;

ExtendedUsage:
	prefix=BasicUsagePrefix keyword+=UsageExtensionKeyword+ usage=Usage
;

AttributeKeyword:
	'attribute'
;

AttributeDefKeyword:
	AttributeKeyword 'def'
;

AttributeUsageKeyword:
	AttributeKeyword
;

AttributeDefinition:
	prefix=DefinitionPrefix AttributeDefKeyword definition=Definition
;

AttributeUsage:
	prefix=UsagePrefix AttributeUsageKeyword usage=Usage
;

EnumerationKeyword:
	'enum'
;

EnumerationDefKeyword:
	EnumerationKeyword 'def'
;

EnumerationUsageKeyword:
	EnumerationKeyword
;

EnumerationDefinition:
	EnumerationDefKeyword
  declaration=DefinitionDeclaration
  body=EnumerationBody
;

EnumerationBody:
	  ';'
	| '{' ( ownedRelationship += AnnotatingMember
		  | ownedRelationship += EnumerationUsageMember
		  )*
	  '}'
;

EnumerationUsageMember:
	prefix=MemberPrefix ownedRelatedElement += EnumeratedValue
;

EnumeratedValue:
	keyword=EnumerationUsageKeyword? usage=Usage
;

EnumerationUsage:
	prefix=UsagePrefix EnumerationUsageKeyword usage=Usage
;

OccurrenceKeyword:
	'occurrence'
;

OccurrenceDefKeyword:
	OccurrenceKeyword 'def'
;

OccurrenceDefinitionPrefix:
	prefix=BasicDefinitionPrefix?
	( isIndividual ?= 'individual' ownedRelationship += LifeClassMembership )?
	keyword=DefinitionExtensionKeyword*
;

OccurrenceDefinition:
	OccurrenceDefinitionPrefix OccurrenceDefKeyword Definition
;

IndividualDefinition:
	BasicDefinitionPrefix? isIndividual ?= 'individual'
	DefinitionExtensionKeyword* 'def' Definition
	ownedRelationship += LifeClassMembership
;

LifeClassMembership:
	ownedRelatedElement += LifeClass
;

LifeClass:	'lifeclass'
;

OccurrenceUsageKeyword:
	OccurrenceKeyword
;

OccurrenceUsagePrefix:
	  prefix=BasicUsagePrefix
	  ( isIndividual ?= 'individual' )?
	  ( portionKind = PortionKind )?
	  usageExtension+=UsageExtensionKeyword*
;

OccurrenceUsage:
	prefix=OccurrenceUsagePrefix OccurrenceUsageKeyword usage=Usage
;

IndividualUsage:
	prefix=BasicUsagePrefix isIndividual ?= 'individual'
	usageExtension+=UsageExtensionKeyword* usage=Usage
;

PortionUsage:
	BasicUsagePrefix ( isIndividual ?= 'individual' )?
	portionKind = PortionKind
	UsageExtensionKeyword* Usage
;

PortionKind:
		snapshot = 'snapshot' | timeslice = 'timeslice'
;

EventOccurrenceUsage:
	 OccurrenceUsagePrefix 'event'
	( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
   	| OccurrenceUsageKeyword UsageDeclaration? )
    UsageCompletion
;

EmptySuccessionMember:
	ownedRelatedElement += EmptySuccession
;

EmptySuccession:
	'then' ownedRelationship += MultiplicitySourceEndMember
;

MultiplicitySourceEndMember:
	ownedRelatedElement += MultiplicitySourceEnd
;

MultiplicitySourceEnd:
	 ( ownedRelationship += OwnedMultiplicity )?
;

ItemKeyword:
	'item'
;

ItemDefKeyword:
	ItemKeyword 'def'
;

ItemUsageKeyword:
	ItemKeyword
;

ItemDefinition:
	prefix=OccurrenceDefinitionPrefix ItemDefKeyword definition=Definition
;

ItemUsage:
	prefix=OccurrenceUsagePrefix ItemUsageKeyword usage=Usage
;

PartKeyword:
	'part'
;

PartDefKeyword:
	PartKeyword 'def'
;

PartUsageKeyword:
	PartKeyword
;

PartDefinition:
	prefix = OccurrenceDefinitionPrefix PartDefKeyword definition = Definition
;

PartUsage:
	prefix=OccurrenceUsagePrefix PartUsageKeyword usage=Usage
;

PortKeyword:
	'port'
;

PortDefKeyword:
	PortKeyword 'def'
;

PortDefinition:
	prefix=DefinitionPrefix PortDefKeyword definition=Definition
	;

ConjugatedPortDefinitionMember:
	ownedRelatedElement += ConjugatedPortDefinition
;

ConjugatedPortDefinition:
	ownedRelationship += PortConjugation
;

PortConjugation:	'portconjugation'
;

ConjugatedPortTyping:
	conjugatedPortDefinition = ConjugatedQualifiedName
;

ConjugatedQualifiedName:
	'~' QualifiedName
;

PortUsageKeyword:
	PortKeyword
;

PortUsage:
	prefix=OccurrenceUsagePrefix PortUsageKeyword usage=Usage
;

ConnectorEndMember:
	ownedRelatedElement += ConnectorEnd
;

ConnectorEnd:
	( declaredName = Name ReferencesKeyword )?
	ownedRelationship += OwnedReferenceSubsetting
	( ownedRelationship += OwnedMultiplicity )?
;

BindingKeyword:
	'binding'
;

BindingConnector:
	prefix=UsagePrefix ( BindingKeyword declaration=UsageDeclaration? )?
	'bind' ownedRelationship += ConnectorEndMember
	'=' ownedRelationship += ConnectorEndMember
	body=DefinitionBody
;

SuccessionKeyword:
	'succession'
;

Succession:
	prefix=UsagePrefix ( SuccessionKeyword declaration=UsageDeclaration? )?
	'first' ownedRelationship += ConnectorEndMember
	'then' ownedRelationship += ConnectorEndMember
	body=DefinitionBody
;

ConnectionKeyword:
	'connection'
;

ConnectionDefKeyword:
	ConnectionKeyword 'def'
;

ConnectionDefinition:
	prefix=OccurrenceDefinitionPrefix ConnectionDefKeyword definition=Definition
;

ConnectorKeyword:
	'connect'
;

ConnectionUsageKeyword:
	ConnectionKeyword
;

ConnectionUsage:
	prefix=OccurrenceUsagePrefix
	(
    ConnectionUsageKeyword declaration=UsageDeclaration? ( ConnectorKeyword part=ConnectorPart )?
  |
    ConnectorKeyword part=ConnectorPart
  )
  body=UsageBody
;

ConnectorPart:
	part=BinaryConnectorPart | part=NaryConnectorPart
;

BinaryConnectorPart:
	ownedRelationship += ConnectorEndMember 'to'
	ownedRelationship += ConnectorEndMember
;

NaryConnectorPart:
	'(' ownedRelationship += ConnectorEndMember ','
	    ownedRelationship += ConnectorEndMember
	    ( ',' ownedRelationship += ConnectorEndMember )* ')'
;

EmptySourceEndMember:
	ownedRelatedElement += EmptySourceEnd
;

EmptySourceEnd:	'emptysourceend'
;

FlowConnectionKeyword:
	'flow'
;

FlowConnectionDefKeyword:
	FlowConnectionKeyword 'def'
;

FlowConnectionDefinition:
	prefix=OccurrenceDefinitionPrefix FlowConnectionDefKeyword definition=Definition
;

MessageKeyword:
	'message'
;

Message:
	OccurrenceUsagePrefix MessageKeyword MessageDeclaration DefinitionBody
;

MessageDeclaration:
	  UsageDeclaration? ValuePart?
      ( 'of' ownedRelationship += ItemFeatureMember )?
      ( 'from' ownedRelationship += MessageEventMember
        'to' ownedRelationship += MessageEventMember
      )?
    | ownedRelationship += MessageEventMember 'to'
	  ownedRelationship += MessageEventMember
;

MessageEventMember:
	ownedRelatedElement += MessageEvent
;

MessageEvent:
	ownedRelationship += OwnedReferenceSubsetting
;

FlowConnectionUsage:
	prefix=OccurrenceUsagePrefix FlowConnectionKeyword
	declaration=FlowConnectionDeclaration body=DefinitionBody
;

SuccessionFlowConnectionKeyword:
	SuccessionKeyword FlowConnectionKeyword
;

SuccessionFlowConnectionUsage:
	prefix=OccurrenceUsagePrefix SuccessionFlowConnectionKeyword
	declaration=FlowConnectionDeclaration body=DefinitionBody
;

FlowConnectionDeclaration:
	  ownedRelationship_from = FlowEndMember 'to' ownedRelationship_to = FlowEndMember
    | declaration=UsageDeclaration? valuepart=ValuePart?
       ( 'of'  ownedRelationship_of = ItemFeatureMember )?
       ( 'from' ownedRelationship_from = FlowEndMember 'to' ownedRelationship_to = FlowEndMember )?
;

ItemFeatureMember:
	ownedRelatedElement += ItemFeature
;

ItemFeature:
	  ownedRelatedElement = PayloadFeature
;

PayloadFeature:
	  identification=Identification? pfsp=PayloadFeatureSpecializationPart valuepart=ValuePart?
	| identification=Identification? valuepart=ValuePart
    | ownedRelationship = OwnedFeatureTyping ( multiplicity2 = OwnedMultiplicity )?
    | multiplicity1 = OwnedMultiplicity ownedRelationship = OwnedFeatureTyping
;

PayloadFeatureSpecializationPart:
	  (ownedRelationship+=FeatureSpecialization)+ mp=MultiplicityPart? ownedRelationship2+=FeatureSpecialization*
	| mp=MultiplicityPart ownedRelationship+=FeatureSpecialization+
;

FlowEndMember:
	ownedRelatedElement += FlowEnd
;

FlowEnd:
	( fes += FlowEndSubsetting )?
	ffm += FlowFeatureMember
;

FlowEndSubsetting:
	  ownedRelatedElement += FeatureChainPrefix
	| referencedFeature = QualifiedName '.'
;

FeatureChainPrefix:
  ( ownedRelationship += OwnedFeatureChaining '.' )+
  ownedRelationship += OwnedFeatureChaining '.'
;

FlowFeatureMember:
	ownedRelatedElement += FlowFeature
;

FlowFeature:
	ownedRelationship += FlowRedefinition
;

FlowRedefinition:
	redefinedFeature = QualifiedName
;

InterfaceKeyword:
	'interface'
;

InterfaceDefKeyword:
	InterfaceKeyword 'def'
;

InterfaceDefinition:
	prefix=OccurrenceDefinitionPrefix InterfaceDefKeyword declaration=DefinitionDeclaration body=InterfaceBody
;

InterfaceBody:
	';' | '{' item+=InterfaceBodyItem* '}'
;

InterfaceBodyItem:
	  ownedRelationship += DefinitionMember
	| ownedRelationship += VariantUsageMember
	| ownedRelationship += InterfaceNonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
	  ownedRelationship += InterfaceOccurrenceUsageMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

InterfaceNonOccurrenceUsageMember:
	MemberPrefix ownedRelatedElement += InterfaceNonOccurrenceUsageElement
;

InterfaceNonOccurrenceUsageElement:
	  ReferenceUsage
	| AttributeUsage
	| EnumerationUsage
	| BindingConnector
	| Succession
;

InterfaceOccurrenceUsageMember:
	prefix=MemberPrefix ownedRelatedElement += InterfaceOccurrenceUsageElement
;

InterfaceOccurrenceUsageElement:
	element=DefaultInterfaceEnd | element=StructureUsageElement | element=BehaviorUsageElement
;

DefaultInterfaceEnd:
	( direction = FeatureDirection )?
	( isAbstract ?= 'abstract' | isVariation ?= 'variation')?
	isEnd ?= 'end' usage=Usage
;

InterfaceUsageKeyword:
	InterfaceKeyword
;

InterfaceUsage:
	prefix=OccurrenceUsagePrefix InterfaceUsageKeyword declaration=InterfaceUsageDeclaration body=InterfaceBody
;

InterfaceUsageDeclaration:
	declaration=UsageDeclaration? ( ConnectorKeyword part1=InterfacePart )? | part2=InterfacePart
;

InterfacePart:
	binarypart=BinaryInterfacePart | narypart=NaryInterfacePart
;

BinaryInterfacePart:
	ownedRelationship += InterfaceEndMember 'to'
	ownedRelationship += InterfaceEndMember
;

NaryInterfacePart:
	'(' ownedRelationship += InterfaceEndMember ','
	    ownedRelationship += InterfaceEndMember
	    ( ',' ownedRelationship += InterfaceEndMember )* ')'
;

InterfaceEndMember:
	ownedRelatedElement = InterfaceEnd
;

InterfaceEnd:
	( declaredName = Name ReferencesKeyword )?
	ownedRelationship += OwnedReferenceSubsetting
	( ownedRelationship += OwnedMultiplicity )?
;

AllocationKeyword:
	'allocation'
;

AllocationDefKeyword:
	AllocationKeyword 'def'
;

AllocationDefinition:
	OccurrenceDefinitionPrefix AllocationDefKeyword Definition
;

AllocationUsageKeyword:
	AllocationKeyword
;

AllocateKeyword:
	'allocate'
;

AllocationUsage:
	OccurrenceUsagePrefix AllocationUsageDeclaration UsageBody
;

AllocationUsageDeclaration:
	    AllocationUsageKeyword UsageDeclaration? ( AllocateKeyword ConnectorPart )?
	  | AllocateKeyword ConnectorPart
;

ActionKeyword:
	'action'
;

ActionDefKeyword:
	ActionKeyword 'def'
;

ActionDefinition:
	prefix=OccurrenceDefinitionPrefix ActionDefKeyword declaration=DefinitionDeclaration body=ActionBody
;

ActionBody:
	  ';'
	  	  	| '{' items += ActionBodyItem* '}'
;

ActionBodyItemTarget:
    ( member=BehaviorUsageMember | member=ActionNodeMember )
;

ActionBodyItem:
	  ownedRelationship = Import
	| ownedRelationship = AliasMember
	| ownedRelationship = DefinitionMember
	| ownedRelationship = VariantUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship = StructureUsageMember
	| ownedRelationship = InitialNodeMember
	  ( target += TargetSuccessionMember )*
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship = ActionBodyItemTarget
	  ( target += TargetSuccessionMember )*
	| ownedRelationship = GuardedSuccessionMember
	| ownedRelationship = NonOccurrenceUsageMember
;

InitialNodeMember:
	MemberPrefix 'first' memberElement = QualifiedName
	RelationshipBody
;

ActionNodeMember:
	prefix=MemberPrefix ownedRelatedElement = ActionNode
;

TargetSuccessionMember:
	MemberPrefix ownedRelatedElement += ActionTargetSuccession
;

GuardedSuccessionMember:
	ownedRelatedElement += GuardedSuccession
;

ActionUsageKeyword:
	ActionKeyword
;

ActionUsage:
	prefix=OccurrenceUsagePrefix ActionUsageKeyword declaration=ActionUsageDeclaration body=ActionBody
;

PerformActionUsage:
	prefix=OccurrenceUsagePrefix 'perform' declaration=PerformActionUsageDeclaration body=ActionBody
;

PerformActionUsageDeclaration:
   	( ownedRelationship = OwnedReferenceSubsetting fspart=FeatureSpecializationPart?
   	| ActionUsageKeyword declaration=UsageDeclaration? )
    valuepart=ValuePart?
;

ActionUsageDeclaration:
	  declaration=UsageDeclaration? valuepart=ValuePart?
;

ActionNode:
	  node=SendNode
  | node=AcceptNode
  | node=AssignmentNode
	| node=IfNode
  | node=WhileLoopNode
  | node=ForLoopNode
	| node=ControlNode
;

ActionNodeUsageDeclaration:
	ActionUsageKeyword declaration=UsageDeclaration?
;

ActionNodePrefix:
	OccurrenceUsagePrefix ActionNodeUsageDeclaration?
;

AcceptNode:
	prefix=OccurrenceUsagePrefix declaration=AcceptNodeDeclaration body=ActionBody
;

AcceptNodeDeclaration:
	declaration=ActionNodeUsageDeclaration? 'accept' part=AcceptParameterPart
;

AcceptParameterPart:
	ownedRelationship += PayloadParameterMember ('via' ownedRelationship += NodeParameterMember)?
;

PayloadParameterMember:
	ownedRelatedElement = PayloadParameter
;

PayloadParameter:
	  feature=PayloadFeature
	| identification=Identification? pfsp=PayloadFeatureSpecializationPart? tvp=TriggerValuePart
;

TriggerValuePart:
	ownedRelationship = TriggerFeatureValue
;

TriggerFeatureValue:
	ownedRelatedElement = TriggerExpression
;

TriggerExpression:
	  kind = TimeTriggerKind
	  ownedRelationship = OwnedExpressionMember
	| ChangeTriggerKind
	  ownedRelationship = ChangeExpressionMember
;

TimeTriggerKind:
	isAt ?= 'at' | isAfter ?= 'after'
;

ChangeTriggerKind:
	'when'
;

ChangeExpressionMember:
	ownedRelatedElement = ChangeExpression
;

ChangeExpression:
	ownedRelationship = ChangeResultExpressionMember
;

ChangeResultExpressionMember:
	ownedRelatedElement = OwnedExpression
;

SendNode:
	OccurrenceUsagePrefix SendNodeDeclaration ActionBody
;

SendNodeDeclaration:
	ActionNodeUsageDeclaration? 'send' ownedRelationship += NodeParameterMember
	( 'via' ownedRelationship += NodeParameterMember)
	( 'to' ownedRelationship += NodeParameterMember)
;

NodeParameterMember:
	ownedRelatedElement = NodeParameter
;

NodeParameter:
	 ownedRelationship = FeatureBinding
;

FeatureBinding:
	ownedRelatedElement = OwnedExpression
;

AssignmentNode:
	prefix=OccurrenceUsagePrefix declaration=AssignmentNodeDeclaration body=ActionBody
;

AssignmentNodeDeclaration:
	declaration=ActionNodeUsageDeclaration? 'assign'
	ownedRelationship1 = FeatureChainMember ':='
	ownedRelationship2 = NodeParameterMember
;

TargetBinding:
	ownedRelatedElement += TargetExpression
;

TargetExpression:
	BaseExpression
	( (  '.'
	  ownedRelationship += FeatureChainMember
	  )?
	  (
	    operator = '[' operand += SequenceExpression ']'
	  |  '->'
	    ownedRelationship += ReferenceTyping
	    ( ownedRelationship += ExpressionBodyMember
	    | ownedRelationship += FunctionReferenceMember
	    | ArgumentList
	    )
	  |  '.'
	    ownedRelationship += ExpressionBodyMember
	  |  '.?'
	    ownedRelationship += ExpressionBodyMember
	  )
	)*
;

ExpressionParameterMember:
	ownedRelatedElement += OwnedExpression
;

IfNodeElseMember:
    ( ActionBodyParameterMember | IfNodeParameterMember )
;

IfNode:
	ActionNodePrefix
	'if' ownedRelationship += ExpressionParameterMember
	ownedRelationship += ActionBodyParameterMember
	( 'else' ownedRelationship += IfNodeElseMember )?
;

ActionBodyParameterMember:
	ownedRelatedElement += ActionBodyParameter
;

ActionBodyParameter:
	 ( ActionUsageKeyword UsageDeclaration? )? '{' items+=ActionBodyItem* '}'
;

IfNodeParameterMember:
	ownedRelatedElement += IfNode
;

WhileLoopNode:
	ActionNodePrefix
	( 'while' ownedRelationship += ExpressionParameterMember | 'loop')
	ownedRelationship += ActionBodyParameterMember
	( 'until' ownedRelationship += ExpressionParameterMember ';' )?
;

ForLoopNode:
	ActionNodePrefix
	'for' ownedRelationship += ForVariableDeclarationMember
	'in' ownedRelationship += NodeParameterMember
	ownedRelationship += ActionBodyParameterMember
;

ForVariableDeclarationMember:
	ownedRelatedElement += ForVariableDeclaration
;

ForVariableDeclaration:
	UsageDeclaration
;

ControlNode:
	  MergeNode
	| DecisionNode
	| JoinNode
	| ForkNode
;

ControlNodePrefix:
	  RefPrefix
	  ( isIndividual ?= 'individual' )?
	  ( portionKind = PortionKind )?
;

MergeNode:
	ControlNodePrefix 'merge' UsageDeclaration?
	ActionNodeBody
;

DecisionNode:
	ControlNodePrefix 'decide' UsageDeclaration?
	ActionNodeBody
;

JoinNode:
	ControlNodePrefix 'join' UsageDeclaration?
	ActionNodeBody
;

ForkNode:
	ControlNodePrefix 'fork' UsageDeclaration?
	ActionNodeBody
;

ActionNodeBody:
	';' | '{' ( ownedRelationship += AnnotatingMember )* '}'
;

ActionTargetSuccession:
	( TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession )
	UsageBody
;

TargetSuccession:
	'then' ownedRelationship += MultiplicitySourceEndMember
	ownedRelationship += ConnectorEndMember
;

GuardedTargetSuccession:
	ownedRelationship += GuardExpressionMember
	'then' ownedRelationship += TransitionSuccessionMember
;

DefaultTargetSuccession:
	'else' ownedRelationship += TransitionSuccessionMember
;

GuardedSuccession:
	( SuccessionKeyword UsageDeclaration )? 'first'
	ownedRelationship += TransitionSourceMember
	ownedRelationship += GuardExpressionMember
	'then' ownedRelationship += TransitionSuccessionMember
	UsageBody
;

StateKeyword:
	'state'
;

StateDefKeyword:
	StateKeyword 'def'
;

StateDefinition:
	prefix=OccurrenceDefinitionPrefix StateDefKeyword declaration=DefinitionDeclaration body=StateDefBody
;

StateDefBody:
	';' | ( isParallel ?= 'parallel' )? '{' part=StateBodyPart '}'
;

StateBodyPart:
		 item+=StateBodyItem*
;

StateBodyItem:
	  ownedRelationship = Import
	| ownedRelationship = AliasMember
	| ownedRelationship = DefinitionMember
	| ownedRelationship = VariantUsageMember
	| ownedRelationship = NonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship += StructureUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship += BehaviorUsageMember
	  ( ownedRelationship += TargetTransitionUsageMember )*
	| ownedRelationship = TransitionUsageMember
	| ownedRelationship += EntryActionMember
	  ( ownedRelationship += EntryTransitionMember )*
	| ownedRelationship = DoActionMember
	| ownedRelationship = ExitActionMember
;

EntryActionMember:
	prefix=MemberPrefix EntryActionKind ownedRelatedElement=StateActionUsage
;

EntryActionKind:
	'entry'
;

DoActionMember:
	prefix=MemberPrefix DoActionKind ownedRelatedElement=StateActionUsage
;

DoActionKind:
	'do'
;

ExitActionMember:
	prefix=MemberPrefix ExitActionKind ownedRelatedElement=StateActionUsage
;

ExitActionKind:
	'exit'
;

EntryTransitionMember:
	prefix=MemberPrefix
	( ownedRelatedElement=GuardedTargetSuccession
	| 'then' ownedRelatedElement=TransitionSuccession
	) ';'
;

StateActionUsage:
	';' | pau=PerformedActionUsage body=ActionBody
;

PerformedActionUsage:
	   declaration=PerformActionUsageDeclaration
	|  declaration=AcceptNodeDeclaration
	|  declaration=SendNodeDeclaration
	|  declaration=AssignmentNodeDeclaration
;

TransitionUsageMember:
	prefix=MemberPrefix ownedRelatedElement=TransitionUsage
;

TargetTransitionUsageMember:
	prefix=MemberPrefix ownedRelatedElement=TargetTransitionUsage
;

StateUsageKeyword:
	StateKeyword
;

StateUsage:
	prefix=OccurrenceUsagePrefix StateUsageKeyword declaration=ActionUsageDeclaration body=StateUsageBody
;

StateUsageBody:
	body=StateDefBody
;

ExhibitStateUsage:
    OccurrenceUsagePrefix 'exhibit'
    ( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
    | StateUsageKeyword UsageDeclaration?
    )
    ValuePart? StateUsageBody
;

TransitionUsageKeyword:
	'transition'
;

TransitionUsage:
	TransitionUsageKeyword ( declaration=UsageDeclaration? 'first' )?
	ownedRelationship += TransitionSourceMember
	( ownedRelationship += TriggerActionMember )?
	( ownedRelationship += GuardExpressionMember )?
	( ownedRelationship += EffectBehaviorMember )?
	'then' ownedRelationship += TransitionSuccessionMember
	body=ActionBody
;

TargetTransitionUsage:
	TransitionUsageKeyword?
	((
    (ownedRelationship1 = TriggerActionMember)
	  (ownedRelationship2 = GuardExpressionMember)?
	  (ownedRelationship3 = EffectBehaviorMember)?
  ) | (
    (ownedRelationship2 = GuardExpressionMember)
    (ownedRelationship3 = EffectBehaviorMember)?
  ) | (
    (ownedRelationship3 = EffectBehaviorMember)
  ))
	'then' ownedRelationship4 = TransitionSuccessionMember
	body=ActionBody
;

TransitionSourceMember:
	  ownedRelatedElement += OwnedFeatureChain
	| memberElement = QualifiedName
;

TriggerActionMember:
	TriggerFeatureKind ownedRelatedElement=TriggerAction
;

TriggerFeatureKind:
	trigger = 'accept'
;

TriggerAction:
	part=AcceptParameterPart
;

GuardExpressionMember:
	GuardFeatureKind ownedRelatedElement=OwnedExpression
;

GuardFeatureKind:
	guard = 'if'
;

EffectBehaviorMember:
	EffectFeatureKind ownedRelatedElement=EffectBehaviorUsage
;

EffectFeatureKind:
	effect = 'do'
;

EffectBehaviorUsage:
	  usage=PerformedActionUsage ( '{' item+=ActionBodyItem* '}' )?
;

TransitionSuccessionMember:
	ownedRelatedElement = TransitionSuccession
;

TransitionSuccession:
	ownedRelationship = ConnectorEndMember
;

CalculationKeyword:
	'calc'
;

CalculationDefKeyword:
	CalculationKeyword 'def'
;

CalculationDefinition:
	prefix=OccurrenceDefinitionPrefix CalculationDefKeyword declaration=DefinitionDeclaration
	body=CalculationBody
;

CalculationBody:
	';' | '{' part+=CalculationBodyPart '}'
;

CalculationBodyPart:
 item += CalculationBodyItem*
	( ownedRelationship += ResultExpressionMember )?
;

CalculationBodyItem:
	  item = ActionBodyItem
	| ownedRelationship = ReturnParameterMember
;

ReturnParameterMember:
	prefix=MemberPrefix 'return' ownedRelatedElement=UsageElement
;

ResultExpressionMember:
	prefix=MemberPrefix ownedRelatedElement=OwnedExpression
;

CalculationUsageKeyword:
	CalculationKeyword
;

CalculationUsage:
	prefix=OccurrenceUsagePrefix CalculationUsageKeyword declaration=CalculationUsageDeclaration body=CalculationBody
;

CalculationUsageDeclaration:
	  declaration=UsageDeclaration? valuepart=ValuePart?
;

ConstraintKeyword:
	'constraint'
;

ConstraintDefKeyword:
	ConstraintKeyword 'def'
;

ConstraintDefinition:
	prefix=OccurrenceDefinitionPrefix ConstraintDefKeyword declaration=DefinitionDeclaration body=CalculationBody
;

ConstraintUsageKeyword:
	ConstraintKeyword
;

ConstraintUsage:
	prefix=OccurrenceUsagePrefix ConstraintUsageKeyword declaration=CalculationUsageDeclaration body=CalculationBody
;

AssertConstraintUsage:
	prefix=OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' )?
    ( ownedRelationship += OwnedReferenceSubsetting featurespecializationpart=FeatureSpecializationPart?
    | ConstraintUsageKeyword declaration=UsageDeclaration?
    )
    body=CalculationBody
;

RequirementKeyword:
	'requirement'
;

RequirementDefKeyword:
	RequirementKeyword 'def'
;

RequirementDefinition:
	prefix=OccurrenceDefinitionPrefix RequirementDefKeyword declaration=DefinitionDeclaration body=RequirementBody
;

RequirementBody:
	  ';' | '{' item+=RequirementBodyItem* '}'
;

RequirementBodyItem:
	  ownedRelationship = DefinitionBodyItem
	| ownedRelationship = SubjectMember
	| ownedRelationship = RequirementConstraintMember
	| ownedRelationship = FramedConcernMember
	| ownedRelationship = RequirementVerificationMember
	| ownedRelationship = ActorMember
	| ownedRelationship = StakeholderMember
;

SubjectMember:
	prefix=MemberPrefix ownedRelatedElement = SubjectUsage
;

SubjectUsage:
	'subject' keyword+=UsageExtensionKeyword* usage=Usage
;

RequirementConstraintMember:
	prefix=MemberPrefix kind = RequirementConstraintKind
	ownedRelatedElement = RequirementConstraintUsage
;

RequirementConstraintKind:
	assumption = 'assume' | requirement = 'require'
;

RequirementConstraintUsage:
    (
      ownedRelationship = OwnedReferenceSubsetting fs+=FeatureSpecialization*
      body=RequirementBody
    )
    |
    (
      (
        keyword1+=UsageExtensionKeyword* ConstraintUsageKeyword
        |
        keyword2+=UsageExtensionKeyword+
      )
      declaration=CalculationUsageDeclaration body=CalculationBody
    )
;

FramedConcernMember:
	MemberPrefix kind = FramedConcernKind
	ownedRelatedElement += FramedConcernUsage
;

FramedConcernKind:
	requirement = 'frame'
;

FramedConcernUsage:
      ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization*
      RequirementBody
    | ( UsageExtensionKeyword* ConcernUsageKeyword | UsageExtensionKeyword+ )
      CalculationUsageDeclaration CalculationBody
;

ActorMember:
	MemberPrefix
	ownedRelatedElement += ActorUsage
;

ActorUsage:
      'actor' UsageExtensionKeyword* Usage
;

StakeholderMember:
	MemberPrefix
	ownedRelatedElement += StakeholderUsage
;

StakeholderUsage:
      'stakeholder' UsageExtensionKeyword* Usage
;

RequirementUsageKeyword:
	RequirementKeyword
;

RequirementUsage:
	prefix=OccurrenceUsagePrefix RequirementUsageKeyword declaration=CalculationUsageDeclaration body=RequirementBody
;

SatisfyRequirementUsage:
	prefix=OccurrenceUsagePrefix (isAssert ?= 'assert')? ( isNegated ?= 'not' )? 'satisfy'
	( ors = OwnedReferenceSubsetting fsp=FeatureSpecializationPart?
    | RequirementUsageKeyword declaration=UsageDeclaration?
  )
  valuepart=ValuePart? ( 'by' ssm = SatisfactionSubjectMember )?
  body=RequirementBody
;

SatisfactionSubjectMember:
	ownedRelatedElement = SatisfactionParameter
;

SatisfactionParameter:
	ownedRelationship = SatisfactionFeatureValue
;

SatisfactionFeatureValue:
	ownedRelatedElement = SatisfactionReferenceExpression
;

SatisfactionReferenceExpression:
	ownedRelationship = FeatureChainMember
;

ConcernKeyword:
	'concern'
;

ConcernDefKeyword:
	ConcernKeyword 'def'
;

ConcernDefinition:
	OccurrenceDefinitionPrefix ConcernDefKeyword DefinitionDeclaration RequirementBody
;

ConcernUsageKeyword:
	ConcernKeyword
;

ConcernUsage:
	OccurrenceUsagePrefix ConcernUsageKeyword CalculationUsageDeclaration RequirementBody
;

CaseKeyword:
	'case'
;

CaseDefKeyword:
	CaseKeyword 'def'
;

CaseDefinition:
	OccurrenceDefinitionPrefix CaseDefKeyword DefinitionDeclaration CaseBody
;

CaseBody:
	    ';'
	  | '{' item+=CaseBodyItem* ( ownedRelationship = ResultExpressionMember )?
	    '}'
;

CaseBodyItem:
	  ownedRelationship = CalculationBodyItem
	| ownedRelationship = SubjectMember
	| ownedRelationship = ActorMember
	| ownedRelationship = ObjectiveMember
;

ObjectiveMember:
	prefix=MemberPrefix 'objective' ownedRelatedElement=ObjectiveRequirementUsage
;

ObjectiveRequirementUsage:
	keyword+=UsageExtensionKeyword* declaration=CalculationUsageDeclaration body=RequirementBody
;

CaseUsageKeyword:
	CaseKeyword
;

CaseUsage:
	OccurrenceUsagePrefix CaseUsageKeyword CalculationUsageDeclaration CaseBody
;

AnalysisCaseKeyword:
	'analysis'
;

AnalysisCaseDefKeyword:
	AnalysisCaseKeyword 'def'
;

AnalysisCaseUsageKeyword:
	AnalysisCaseKeyword
;

AnalysisCaseDefinition:
	prefix=OccurrenceDefinitionPrefix AnalysisCaseDefKeyword
  declaration=DefinitionDeclaration body=CaseBody
;

AnalysisCaseUsage:
	prefix=OccurrenceUsagePrefix AnalysisCaseUsageKeyword
  declaration=CalculationUsageDeclaration body=CaseBody
;

VerificationCaseKeyword:
	'verification'
;

VerificationCaseDefKeyword:
	VerificationCaseKeyword 'def'
;

VerificationCaseUsageKeyword:
	VerificationCaseKeyword
;

VerificationCaseDefinition:
	OccurrenceDefinitionPrefix VerificationCaseDefKeyword DefinitionDeclaration CaseBody
;

VerificationCaseUsage:
	OccurrenceUsagePrefix VerificationCaseUsageKeyword CalculationUsageDeclaration CaseBody
;

RequirementVerificationMember:
	MemberPrefix kind = RequirementVerificationKind
	ownedRelatedElement += RequirementVerificationUsage
;

RequirementVerificationKind:
	requirement = 'verify'
;

RequirementVerificationUsage:
      ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization*
      RequirementBody
    | ( UsageExtensionKeyword* RequirementUsageKeyword | UsageExtensionKeyword+ )
      CalculationUsageDeclaration RequirementBody
;

UseCaseKeyword:
	'use' 'case'
;

UseCaseDefKeyword:
	UseCaseKeyword 'def'
;

UseCaseUsageKeyword:
	UseCaseKeyword
;

UseCaseDefinition:
	OccurrenceDefinitionPrefix UseCaseDefKeyword DefinitionDeclaration CaseBody
;

UseCaseUsage:
	OccurrenceUsagePrefix UseCaseUsageKeyword CalculationUsageDeclaration CaseBody
;

IncludeUseCaseUsage:
	OccurrenceUsagePrefix 'include'
   	( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
   	| UseCaseUsageKeyword UsageDeclaration? )
    ValuePart?
	CaseBody
;

ViewKeyword:
	'view'
;

ViewDefKeyword:
	ViewKeyword 'def'
;

ViewDefinition:
	OccurrenceDefinitionPrefix ViewDefKeyword DefinitionDeclaration ViewDefinitionBody
;

ViewDefinitionBody:
	  ';'
	| '{' ViewDefinitionBodyItem* '}'
;

ViewDefinitionBodyItem:
	  DefinitionBodyItem
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += ViewRenderingMember
;

ViewRenderingMember:
	MemberPrefix 'render'
	ownedRelatedElement += ViewRenderingUsage
;

ViewRenderingUsage:
	 ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization* UsageBody
;

ViewUsageKeyword:
	ViewKeyword
;

ViewUsage:
	OccurrenceUsagePrefix ViewUsageKeyword UsageDeclaration? ValuePart? ViewBody
;

ViewBody:
	';' | '{' ViewBodyItem* '}'
;

ViewBodyItem:
	  DefinitionBodyItem
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += Expose
	| ownedRelationship += ViewRenderingMember
;

Expose:
	( MembershipExpose | NamespaceExpose )
	RelationshipBody
;

MembershipExpose:
	( visibility = VisibilityIndicator )?
	'expose' ImportedMembership
;

NamespaceExpose:
	( visibility = VisibilityIndicator )?
	'expose'
	( ImportedNamespace
	| ownedRelatedElement += FilterPackage
	)
;

ViewpointKeyword:
	'viewpoint'
;

ViewpointDefKeyword:
	ViewpointKeyword 'def'
;

ViewpointUsageKeyword:
	ViewpointKeyword
;

ViewpointDefinition:
	OccurrenceDefinitionPrefix ViewpointDefKeyword DefinitionDeclaration RequirementBody
;

ViewpointUsage:
	OccurrenceUsagePrefix ViewpointUsageKeyword CalculationUsageDeclaration RequirementBody
;

RenderingKeyword:
	'rendering'
;

RenderingDefKeyword:
	RenderingKeyword 'def'
;

RenderingDefinition:
	OccurrenceDefinitionPrefix RenderingDefKeyword Definition
;

RenderingUsageKeyword:
	RenderingKeyword
;

RenderingUsage:
	OccurrenceUsagePrefix RenderingUsageKeyword Usage
;

ExpressionBody:
	body=CalculationBody
;

RelationshipOwnedElement:
      ownedRelatedElement += OwnedRelatedElement
    | ownedRelationship += OwnedAnnotation
;

OwnedRelatedElement:
    NonFeatureElement | FeatureElement
;

CommentKerML:
	( 'comment' Identification?
	  ('about' ownedRelationship += Annotation
	     ( ',' ownedRelationship += Annotation )* )?
	)?
	body = REGULAR_COMMENT
;

Namespace:
	( ownedRelationship += PrefixMetadataMember )*
	NamespaceDeclaration NamespaceBody
;

NamespaceDeclaration:
	'namespace' Identification?
;

NamespaceBody:
	  ';'
	| '{' ( 					    ownedRelationship += NamespaceMember
	      | ownedRelationship += AliasMember
	      | ownedRelationship += Import )*
	  '}'
;

NamespaceBodyElement:
	  ownedRelationship += NamespaceMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

NamespaceMember:
	  NonFeatureMember | NamespaceFeatureMember
;

NonFeatureMember:
	MemberPrefix ownedRelatedElement += MemberElement
;

NamespaceFeatureMember:
	MemberPrefix ownedRelatedElement += FeatureElement
;

MemberElement:
	AnnotatingElement | NonFeatureElement
;

NonFeatureElement:
	  Dependency
	| Namespace
	| Package
	| LibraryPackage
	| Multiplicity
	| Type
	| Classifier
	| Class
	| Structure
	| Metaclass
	| DataType
	| Association
	| AssociationStructure
	| Interaction
	| Behavior
	| Function
	| Predicate
	| Specialization
	| Conjugation
	| FeatureTyping
	| Subclassification
	| Disjoining
	| FeatureInverting
	| Subsetting
	| Redefinition
	| TypeFeaturing
;

FeatureElement:
	  Feature
	| Step
	| Expression
	| BooleanExpression
	| Invariant
	| Connector
	| BindingConnector
	| Succession
	| ItemFlow
	| SuccessionItemFlow
;

TypePrefix:
	( isAbstract ?= 'abstract' )?
	( ownedRelationship += PrefixMetadataMember )*
;

Type:
    TypePrefix 'type'
    TypeDeclaration TypeBody
;

TypeDeclaration:
    ( isSufficient ?= 'all' )? Identification?
    ( ownedRelationship += OwnedMultiplicity )?
    ( SpecializationPart | ConjugationPart )+
    TypeRelationshipPart*
;

SpecializationPart:
      ( ':>' | 'specializes' ) ownedRelationship += OwnedSpecialization
      ( ',' ownedRelationship += OwnedSpecialization )*
;

ConjugationPart:
	( '~' | 'conjugates' ) ownedRelationship += OwnedConjugation
;

TypeRelationshipPart:
	DisjoiningPart | UnioningPart | IntersectingPart | DifferencingPart
;

DisjoiningPart:
	'disjoint' 'from' ownedRelationship += OwnedDisjoining
	( ',' ownedRelationship += OwnedDisjoining )*
;

UnioningPart:
	'unions' ownedRelationship += Unioning
	( ',' ownedRelationship += Unioning )*
;

IntersectingPart:
	'intersects' ownedRelationship += Intersecting
	( ',' ownedRelationship += Intersecting )*
;

DifferencingPart:
	'differences' ownedRelationship += Differencing
	( ',' ownedRelationship += Differencing )*
;

TypeBody:
	 ';'
	| '{' ( ownedRelationship += NonFeatureMember
		  | ownedRelationship += FeatureMember
		  | ownedRelationship += AliasMember
		  | ownedRelationship += Import
	      )*
	  '}'
;

FeatureMember:
	TypeFeatureMember | OwnedFeatureMember
;

TypeFeatureMember:
	MemberPrefix 'member' ownedRelatedElement += FeatureElement
;

OwnedFeatureMember:
	MemberPrefix ownedRelatedElement += FeatureElement
;

Specialization:
    ( 'specialization' Identification? )?
    'subtype'
	( specific = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
    ( ':>' | 'specializes')
	( general = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

OwnedSpecialization:
	  general = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Conjugation:
	( 'conjugation' Identification? )?
    'conjugate'
    ( conjugatedType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
    ( '~' | 'conjugates')
    ( originalType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

OwnedConjugation:
	  originalType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Disjoining:
	( 'disjoining' Identification? )?
	'disjoint'
	( typeDisjoined = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	'from'
	( disjoiningType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

OwnedDisjoining:
	  disjoiningType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Unioning:
	  unioningType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Intersecting:
	  intersectingType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Differencing:
	  differencingType = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

Classifier:
	TypePrefix 'classifier'
	ClassifierDeclaration TypeBody
;

ClassifierDeclaration:
    (isSufficient ?= 'all' )? Identification?
	( ownedRelationship += OwnedMultiplicity )?
	( SuperclassingPart | ClassifierConjugationPart )?
	TypeRelationshipPart*
;

SuperclassingPart:
	( ':>' | 'specializes' ) ownedRelationship += Ownedsubclassification
	( ',' ownedRelationship += Ownedsubclassification )*
;

ClassifierConjugationPart:
	( '~' | 'conjugates' ) ownedRelationship += ClassifierConjugation
;

Subclassification:
	( 'specialization' Identification? )?
    'subclassifier' subclassifier = QualifiedName
    ( ':>' | 'specializes') superclassifier = QualifiedName
    RelationshipBody
;

Ownedsubclassification:
	superclassifier = QualifiedName
;

ClassifierConjugation:
	originalType = QualifiedName
;

FeaturePrefix:
	( direction = FeatureDirection )?
	( isAbstract ?= 'abstract' )?
	( isComposite ?= 'composite' | isPortion ?= 'portion' )?
	( isReadOnly ?= 'readonly' )?
	( isDerived ?= 'derived' )?
	( isEnd ?= 'end' )?
	( ownedRelationship += PrefixMetadataMember )*
;

Feature:
	FeaturePrefix
	( 'feature'? FeatureDeclaration
	| ownedRelationship += PrefixMetadataMember
	| 'feature'
	)
	ValuePart? TypeBody
;

FeatureRelationshipPart:
	TypeRelationshipPart | ChainingPart | InvertingPart | TypeFeaturingPart
;

ChainingPart:
	'chains' ( ownedRelationship += OwnedFeatureChaining | FeatureChain )
;

InvertingPart:
	'inverse' 'of' ownedRelationship += OwnedFeatureInverting
;

TypeFeaturingPart:
	'featured' 'by' ownedRelationship += OwnedTypeFeaturing
	( ',' ownedRelationship += OwnedTypeFeaturing )*
;

Subsets:
	( ':>' | 'subsets' ) ownedRelationship += OwnedSubsetting
;

Redefines:
	( ':>>' | 'redefines' ) ownedRelationship += OwnedRedefinition
;

FeatureInverting:
	( 'inverting' Identification? )?
	'inverse'
	( featureInverted = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	'of'
	( invertingFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

OwnedFeatureInverting:
	  invertingFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain
;

TypeFeaturing:
	'featuring' ( Identification? 'of')?
	featureOfType = QualifiedName
	'by' featuringType = QualifiedName
	RelationshipBody
;

OwnedTypeFeaturing:
	featuringType = QualifiedName
;

OwnedFeatureTyping:
	type=FeatureType
;

FeatureType:
	  type = QualifiedName | ownedRelatedElement += OwnedFeatureChain
;

Subsetting:
	( 'specialization' Identification? )?
    'subset'
    ( subsettingFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
    ( ':>' | 'subsets' )
    ( subsettedFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

Redefinition:
	( 'specialization' Identification? )?
    'redefinition'
    ( redefiningFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
    ( ':>>' | 'redefines' )
    ( redefinedFeature = QualifiedName
	| ownedRelatedElement += OwnedFeatureChain )
	RelationshipBody
;

FeatureConjugationPart:
	( '~' | 'conjugates' ) ownedRelationship += FeatureConjugation
;

FeatureConjugation:
	originalType = QualifiedName
;

EmptyFeatureWriteMember:
	ownedRelatedElement += EmptyFeatureWrite
;

EmptyFeatureWrite:
	ownedRelationship += EmptyTargetMember
	ownedRelationship += EmptyParameterMember
;

TargetFeatureMember:
	ownedRelatedElement += TargetFeature
;

TargetFeature:
	ownedRelationship += EmptyFeatureMember
;

EmptyFeatureMember:
	ownedRelatedElement += EmptyFeature
;

EmptyParameterMember:
	ownedRelatedElement += EmptyFeature
;

Multiplicity:
	MultiplicitySubset | MultiplicityRange
;

MultiplicitySubset:
	'multiplicity' Identification? Subsets TypeBody
;

OwnedMultiplicityRange:
	MultiplicityBounds
;

MultiplicityBounds:
		'[' ownedRelationship += MultiplicityExpressionMember
	      ( '..' ownedRelationship += MultiplicityExpressionMember )? ']'
;

DataType:
	TypePrefix 'datatype'
	ClassifierDeclaration TypeBody
;

Class:
	TypePrefix 'class'
	ClassifierDeclaration TypeBody
;

Structure:
	TypePrefix 'struct'
	ClassifierDeclaration TypeBody
;

Association:
	TypePrefix 'assoc'
	ClassifierDeclaration TypeBody
;

AssociationStructure:
	TypePrefix 'assoc' 'struct'
	ClassifierDeclaration TypeBody
;

Connector:
	FeaturePrefix 'connector'
	ConnectorDeclaration TypeBody
;

ConnectorDeclaration:
	BinaryConnectorDeclaration | NaryConnectorDeclaration
;

BinaryConnectorDeclaration:
	( FeatureDeclaration? 'from' | isSufficient ?= 'all' 'from'? )?
	ownedRelationship += ConnectorEndMember 'to'
	ownedRelationship += ConnectorEndMember
;

NaryConnectorDeclaration:
	FeatureDeclaration?
	( '(' ownedRelationship += ConnectorEndMember ','
	      ownedRelationship += ConnectorEndMember
	      ( ',' ownedRelationship += ConnectorEndMember )*
	  ')' )?
;

BindingConnectorDeclaration:
	  FeatureDeclaration
	  ( 'of' ownedRelationship += ConnectorEndMember
	    '=' ownedRelationship += ConnectorEndMember )?
	| ( isSufficient ?= 'all' )?
	  ( 'of'? ownedRelationship += ConnectorEndMember
	    '=' ownedRelationship += ConnectorEndMember )?
;

SuccessionDeclaration:
	  FeatureDeclaration
	  ( 'first' ownedRelationship += ConnectorEndMember
	    'then' ownedRelationship += ConnectorEndMember )?
    | ( isSufficient ?= 'all' )?
	  ( 'first'? ownedRelationship += ConnectorEndMember
	    'then' ownedRelationship += ConnectorEndMember )?
;

Behavior:
	TypePrefix 'behavior'
	ClassifierDeclaration TypeBody
;

Step:
	FeaturePrefix 'step'
	StepDeclaration TypeBody
;

StepDeclaration:
	FeatureDeclaration? ValuePart?
;

Function:
	TypePrefix 'function'
	ClassifierDeclaration FunctionBody
;

FunctionBody:
	';' | '{' FunctionBodyPart '}'
;

FunctionBodyPart:
	( ownedRelationship += NonFeatureMember
	| ownedRelationship += FeatureMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
	| ownedRelationship += ReturnFeatureMember
	)*
	( ownedRelationship += ResultExpressionMember )?
;

ReturnFeatureMember:
	MemberPrefix 'return' ownedRelatedElement += FeatureElement
;

Expression:
	FeaturePrefix 'expr'
	ExpressionDeclaration FunctionBody
;

ExpressionDeclaration:
	FeatureDeclaration? ValuePart?
;

Predicate:
	TypePrefix 'predicate'
	ClassifierDeclaration FunctionBody
;

BooleanExpression:
	FeaturePrefix 'bool'
	ExpressionDeclaration FunctionBody
;

Invariant:
	FeaturePrefix 'inv' ( 'true' | isNegated ?= 'false' )?
	ExpressionDeclaration FunctionBody
;

Interaction:
	TypePrefix 'interaction'
	ClassifierDeclaration TypeBody
;

ItemFlow:
	FeaturePrefix 'flow'
	ItemFlowDeclaration TypeBody
;

SuccessionItemFlow:
	FeaturePrefix 'succession' 'flow' ItemFlowDeclaration TypeBody
;

ItemFlowDeclaration:
	  FeatureDeclaration? ValuePart?
      ( 'of'  ownedRelationship += ItemFeatureMember )?
	  ( 'from' ownedRelationship += ItemFlowEndMember
	    'to' ownedRelationship += ItemFlowEndMember )?
    | ( isSufficient ?= 'all' )?
      ownedRelationship += ItemFlowEndMember 'to'
	  ownedRelationship += ItemFlowEndMember
;

ItemFeatureSpecializationPart:
	  ( FeatureSpecialization )+ MultiplicityPart? FeatureSpecialization*
	| MultiplicityPart FeatureSpecialization+
;

ItemFlowEndMember:
	ownedRelatedElement += ItemFlowEnd
;

ItemFlowEnd:
	( ownedRelationship += ItemFlowEndSubsetting )?
	ownedRelationship += ItemFlowFeatureMember
;

ItemFlowEndSubsetting:
	  referencedFeature = QualifiedName '.'
	| ownedRelatedElement += FeatureChainPrefix
;

ItemFlowFeatureMember:
	ownedRelatedElement += ItemFlowFeature
;

ItemFlowFeature:
	ownedRelationship += ItemFlowRedefinition
;

ItemFlowRedefinition:
	redefinedFeature = QualifiedName
;

Metaclass:
	TypePrefix 'metaclass'
	ClassifierDeclaration TypeBody
;

PrefixMetadataFeature:
	ownedRelationship += MetadataTyping
;

MetadataFeature:
	( '@' | 'metadata' ) MetadataFeatureDeclaration
	( 'about' ownedRelationship += Annotation
		( ',' ownedRelationship += Annotation )*
	)?
	MetadataBody
;

MetadataFeatureDeclaration:
	( Identification ( ':' | 'typed' 'by' ) )? ownedRelationship += MetadataTyping
;

MetadataBodyFeatureMember:
	ownedRelatedElement += MetadataBodyFeature
;

MetadataBodyFeature:
	'feature'? ( ':>>' | 'redefines' )? ownedRelationship += OwnedRedefinition
	FeatureSpecializationPart? ValuePart?
	MetadataBody
;

OwnedExpressionMember:
	ownedRelatedElement = OwnedExpression
;

OwnedExpression:
	 expression=ConditionalExpression
;

OwnedExpressionReference:
	ownedRelationship += OwnedExpressionMember
;

ConditionalExpression:
	  operand = NullCoalescingExpression
	|  operator = ConditionalOperator operand += NullCoalescingExpression
		  '?' operand += OwnedExpressionReference 'else' operand += OwnedExpressionReference
;

ConditionalOperator:
	'if'
;

NullCoalescingExpression:
	implies = ImpliesExpression (
		operator = NullCoalescingOperator operand += ImpliesExpressionReference )*
;

NullCoalescingOperator:
	'??'
;

ImpliesExpressionReference:
	ownedRelationship += ImpliesExpressionMember
;

ImpliesExpressionMember:
	ownedRelatedElement += ImpliesExpression
;

ImpliesExpression:
	or = OrExpression (
		operator = ImpliesOperator operand += OrExpressionReference )*
;

ImpliesOperator:
	'implies'
;

OrExpressionReference:
	ownedRelationship += OrExpressionMember
;

OrExpressionMember:
	ownedRelatedElement += OrExpression
;

OrExpression:
	xor=XorExpression (
		( operator = OrOperator operand += XorExpression
		| operator = ConditionalOrOperator operand += XorExpressionReference ) )*
;

OrOperator:
	'|'
;

ConditionalOrOperator:
	'or'
;

XorExpressionReference:
	ownedRelationship += XorExpressionMember
;

XorExpressionMember:
	ownedRelatedElement += XorExpression
;

XorExpression:
	and=AndExpression (
		operator = XorOperator operand += AndExpression )*
;

XorOperator:
	'xor'
;

AndOperand:
  (operator = AndOperator operand = EqualityExpression)
  |
  (operator = ConditionalAndOperator operand = EqualityExpressionReference)
;

AndExpression:
	equality=EqualityExpression
  (operation+=AndOperand)*
;

AndOperator:
    '&'
;

ConditionalAndOperator:
	'and'
;

EqualityExpressionReference:
	ownedRelationship = EqualityExpressionMember
;

EqualityExpressionMember:
	ownedRelatedElement = EqualityExpression
;

EqualityOperand:
  operator=EqualityOperator operand=ClassificationExpression
;

EqualityExpression:
	classification=ClassificationExpression
  (operation+=EqualityOperand)*
;

EqualityOperator:
	'==' | '!=' | '===' | '!=='
;

ClassificationExpression:
	  relational=RelationalExpression
	  (
	  	operator = ClassificationTestOperator ownedRelationship += TypeReferenceMember
	  |
	    operator = CastOperator ownedRelationship += TypeResultMember
	  )?
	|  operand += SelfReferenceExpression
	  operator = ClassificationTestOperator ownedRelationship += TypeReferenceMember
	|  operand += MetadataReference
	  operator = MetaClassificationTestOperator ownedRelationship += TypeReferenceMember
	|  operand += SelfReferenceExpression
	  operator = CastOperator ownedRelationship += TypeResultMember
	|  operand += MetadataReference
	  operator = MetaCastOperator ownedRelationship += TypeResultMember
;

ClassificationTestOperator:
	'hastype' | 'istype' | '@'
;

MetaClassificationTestOperator:
	'@@'
;

CastOperator:
    'as'
;

MetaCastOperator:
	'meta'
;

MetadataReference:
	referencedElement = QualifiedName
;

TypeReferenceMember:
	ownedRelatedElement += TypeReference
;

TypeResultMember:
	ownedRelatedElement += TypeReference
;

TypeReference:
	ownedRelationship += ReferenceTyping
;

ReferenceTyping:
	  type = QualifiedName
;

SelfReferenceExpression:
	ownedRelationship += SelfReferenceMember
;

SelfReferenceMember:
	ownedRelatedElement += EmptyFeature
;

EmptyFeature:	'emptyfeature'
;

RelationalOperand:
  operator=RelationalOperator operand=RangeExpression
;

RelationalExpression:
	range=RangeExpression operation+=RelationalOperand*
;

RelationalOperator:
	'<=' | '>=' | '<' | '>'
;

RangeExpression:
	additive=AdditiveExpression ('..' operand = AdditiveExpression )?
;

AdditiveOperand:
  operator=AdditiveOperator operand=MultiplicativeExpression
;

AdditiveExpression:
	multiplicitive=MultiplicativeExpression
  (operation+=AdditiveOperand)*
;

AdditiveOperator:
	'+' | '-'
;

MultiplicativeOperand:
  operator=MultiplicativeOperator operand=ExponentiationExpression
;

MultiplicativeExpression:
	exponential=ExponentiationExpression operation+=MultiplicativeOperand*
;

MultiplicativeOperator:
	'*' | '/' | '%'
;

ExponentiationExpression:
	unary=UnaryExpression (
		operator = ExponentiationOperator operand += UnaryExpression )*
;

ExponentiationOperator:
	'**' | '^'
;

UnaryExpression:
	   operator = UnaryOperator operand += ExtentExpression
	| extent=ExtentExpression
;

UnaryOperator:
	'+' | '-' | '~' | 'not'
;

ExtentExpression:
	   operator = 'all' ownedRelationship += TypeResultMember
	| primary=PrimaryExpression
;

PrimaryExpression:
	base=BaseExpression
	(  '.' ownedRelationship1 += FeatureChainMember )?
	(
    ( operator += '#' '(' operand += SequenceExpression ')'
      | operator += '[' operand += SequenceExpression ']'
      | operator += '->' ownedRelationship = ReferenceTyping
        ( operand += BodyExpression | operand += FunctionReferenceExpression | operand+= ArgumentList )
      |  operator += '.' operand += BodyExpression
      |  operator += '.?' operand += BodyExpression
	  )
	  (  '.' ownedRelationship2 += FeatureChainMember )?
	)*
;

FunctionReferenceExpression:
	ownedRelationship += FunctionReferenceMember
;

FunctionReferenceMember:
	ownedRelatedElement += FunctionReference
;

FunctionReference:
	ownedRelationship += ReferenceTyping
;

FeatureChainMember:
	  ownedRelatedElement = OwnedFeatureChain
	|  memberElement = QualifiedName
;

BaseExpression:
	  ownedRelationship=NullExpression
	| ownedRelationship=LiteralExpression
	| ownedRelationship=InvocationExpression
  | ownedRelationship=FeatureReferenceExpression
	| ownedRelationship=MetadataAccessExpression
	| ownedRelationship=BodyExpression
	| '(' ownedRelationship=SequenceExpression ')'
;

BodyExpression:
	ownedRelationship = ExpressionBodyMember
;

ExpressionBodyMember:
	ownedRelatedElement = ExpressionBody
;

BodyParameterMember:
	'in' ownedRelatedElement += BodyParameter
;

BodyParameter:
	declaredName = Name
;

SequenceOperand:
  (',' operand = OwnedExpression)
  |
  ','
;

SequenceExpression:
	ownedRelationship=OwnedExpression operation+=SequenceOperand*
;

FeatureReferenceExpression:
	ownedRelationship += FeatureReferenceMember
;

FeatureReferenceMember:
	memberElement = QualifiedName
;

MetadataAccessExpression:
	referencedElement = QualifiedName '.' 'metadata'
;

InvocationExpression:
	ownedRelationship=OwnedFeatureTyping arg_list=ArgumentList
;

OwnedFeatureChain:
	feature=FeatureChain
;

FeatureChain:
	ownedRelationship += OwnedFeatureChaining['.']
;

OwnedFeatureChaining:
	chainingFeature = QualifiedName
;

ArgumentList:
	'(' ( pos_list=PositionalArgumentList | named_list=NamedArgumentList )? ')'
;

PositionalArgumentList:
	ownedRelationship += ArgumentMember[',']
;

ArgumentMember:
	ownedRelatedElement = Argument
;

Argument:
	ownedRelationship = ArgumentValue
;

NamedArgumentList:
	ownedRelationship += NamedArgumentMember[',']
;

NamedArgumentMember:
	ownedRelatedElement = NamedArgument
;

NamedArgument:
	redefinition = ParameterRedefinition '=' value = ArgumentValue
;

ParameterRedefinition:
	redefinedFeature = QualifiedName
;

ArgumentValue:
	ownedRelatedElement = OwnedExpression
;

NullExpression:
	 ( 'null' | '(' ')' )
;

LiteralExpression:
	  LiteralBoolean
	| LiteralString
	| LiteralReal
	| LiteralInteger
	| LiteralInfinity
;

LiteralBoolean:
	value = BooleanValue
;

BooleanValue:
	'true' | 'false'
;

LiteralString:
	value = STRING_VALUE
;

LiteralInteger:
	value = DECIMAL_VALUE
;

LiteralReal:
	value = RealValue
;

RealValue:
	DECIMAL_VALUE? '.' ( DECIMAL_VALUE | EXP_VALUE ) | EXP_VALUE
;

LiteralInfinity:
	 value='*'
;

ReservedKeyword:
  'about' | /to[\s]/ | 'connect' | 'connection' | 'from' | /of[\s]/ | 'then' |
  'entry' | /accept[\s]/ | /do[\s]/ | /exit[\s]/ | /action[\s]/ | /at[\s]/ |
  /assign[\s]/
;

Name:
	!ReservedKeyword ID | UNRESTRICTED_NAME
;

Qualification:
	( '::' Name )+
;

QualifiedName:
	  names+=Name['::']
;

DECIMAL_VALUE:
   /[0-9]+/;

EXP_VALUE:
	DECIMAL_VALUE ('e' | 'E') ('+' | '-')? DECIMAL_VALUE;

ID:
   /[a-zA-Z_][a-zA-Z_0-9]*/;

UNRESTRICTED_NAME:
  
  /[\'].*[\']/;

STRING_VALUE:
	
  /[\"].*[\"]/;

REGULAR_COMMENT:
  /\/\*(.|\n)*?\*\//
;

Comment:
  /\/\/.*$/
;

ML_NOTE:
	/'\/*'->'*\/'/;

SL_NOTE:
	/'\/\/' (!('
' | '
') !('
' | '
')*)? ('
'? '
')?/;

WS:
	/(' ' | '	' | '
' | '
')+/;