import KerML
import KerMLExpressions
/*****************************************************************************
 * SysML 2 Pilot Implementation
 * Copyright (c) 2018-2023 Model Driven Solutions, Inc.
 * Copyright (c) 2018 IncQuery Labs Ltd.
 * Copyright (c) 2019 Maplesoft (Waterloo Maple, Inc.)
 * Copyright (c) 2019 Mgnite Inc.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 * @license LGPL-3.0-or-later <http://spdx.org/licenses/LGPL-3.0-or-later>
 *
 * Contributors:
 *  Ed Seidewitz, MDS
 *  Zoltan Kiss, IncQuery
 *  Balazs Grill, IncQuery
 *  Hisashi Miyashita, Maplesoft/Mgnite
 *
 *****************************************************************************/

/* ROOT NAMESPACE */

RootNamespace :
	 PackageBodyElement*
;

/* BASIC ELEMENTS */

 Identification :
	  '<' declaredShortName = Name '>' ( declaredName = Name )?
	| declaredName = Name
;

 RelationshipBody :
	';' | '{' ( ownedRelationship += OwnedAnnotation )* '}'
;

/* DEPENDENCIES */

Dependency :
	( ownedRelationship += PrefixMetadataAnnotation )*
	'dependency' ( Identification? 'from' )?
    client += QualifiedName ( ',' client += QualifiedName )* 'to'
    supplier += QualifiedName ( ',' supplier += QualifiedName )*
    RelationshipBody
;

/* ANNOTATIONS */

Annotation :
	annotatedElement = QualifiedName
;

OwnedAnnotation :
	ownedRelatedElement += AnnotatingElement
;

AnnotatingMember :
	ownedRelatedElement += AnnotatingElement
;

AnnotatingElement :
	  ownedRelatedElement = CommentSysML
	| ownedRelatedElement = Documentation
	| ownedRelatedElement = TextualRepresentation
	| ownedRelatedElement = MetadataUsage
;

/* Comments */

CommentSysML :
// Comment is reserved in TextX
	( 'comment' identification=Identification?
	  ('about' ownedRelationship += Annotation
	     ( ',' ownedRelationship += Annotation )* )?
	)?
	body = REGULAR_COMMENT
;

Documentation :
	'doc' identification=Identification? body=REGULAR_COMMENT
;

/* Textual Representation */

TextualRepresentation :
    ( 'rep' Identification? )?
    'language' language = STRING_VALUE
    body = REGULAR_COMMENT
;

/* Metadata */

MetadataKeyword :
	'metadata'
;

MetadataDefKeyword :
	MetadataKeyword 'def'
;

MetadataUsageKeyword :
	MetadataKeyword | '@'
;

MetadataDefinition :
	( isAbstract ?= 'abstract')? MetadataDefKeyword
	Definition
;

PrefixMetadataAnnotation :
	'#' ownedRelatedElement += PrefixMetadataUsage
;

PrefixMetadataMember :
	'#' ownedRelatedElement += PrefixMetadataUsage
;

PrefixMetadataUsage :
	ownedRelationship += MetadataTyping
//	( ownedRelationship += MetadataBodyUsageMember )*
;

MetadataUsage :
	MetadataUsageKeyword MetadataUsageDeclaration
	( 'about' ownedRelationship += Annotation
		( ',' ownedRelationship += Annotation )*
	)?
	MetadataBody
;

 MetadataUsageDeclaration :
	( Identification? DefinedByKeyword )? ownedRelationship += MetadataTyping
;

MetadataTyping :
	type = QualifiedName
;

 MetadataBody :
	  ';'
	| '{' ( ownedRelationship += DefinitionMember
		  | ownedRelationship += MetadataBodyUsageMember
		  | ownedRelationship += AliasMember
		  | ownedRelationship += Import
	      )*
	  '}'
;

MetadataBodyUsageMember :
	ownedRelatedElement += MetadataBodyUsage
;

MetadataBodyUsage :
	'ref'? ( ':>>' | 'redefines' )? ownedRelationship += OwnedRedefinition
	FeatureSpecializationPart? ValuePart?
	body=MetadataBody
;

/* PACKAGES */

/* Packages */

Package :
	( ownedRelationship += PrefixMetadataMember )*
	declaration=PackageDeclaration body=PackageBody
;

LibraryPackage :
	( isStandard ?= 'standard' )? 'library'
	( ownedRelationship += PrefixMetadataMember )*
	PackageDeclaration PackageBody
;

PackageDeclaration :
	'package' identification = Identification?
;

 PackageBody :
	 ';'
	| '{' ( // Note: PackageBodyElement is expanded here to avoid
			// infinite loops in the incremental parser.
		    ownedRelationship += PackageMember
		  | ownedRelationship += ElementFilterMember
		  | ownedRelationship += AliasMember
		  | ownedRelationship += Import )*
	  '}'
;

/* Package Bodies */

 PackageBodyElement :
	  ownedRelationship += PackageMember
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

 MemberPrefix :
    ( visibility = VisibilityIndicator )?
;

PackageMember :
	prefix = MemberPrefix
	( ownedRelatedElement = DefinitionElement | ownedRelatedElement = UsageElement)
;

ElementFilterMember :
	prefix = MemberPrefix
	'filter' ownedRelatedElement += OwnedExpression ';'
;

AliasMember :
	prefix = MemberPrefix
	'alias' ( '<' memberShortName = Name '>' )? ( memberName = Name )?
	'for' memberElement = QualifiedName
	body = RelationshipBody
;

ImportPrefix :
	( visibility = VisibilityIndicator )?
	'import' ( isImportAll ?= 'all' )?
;

Import :
	(ownedRelationship = NamespaceImport | ownedRelationship = MembershipImport)
	body = RelationshipBody
;

NamespaceImport :
	prefix = ImportPrefix
	( namespace = ImportedNamespace | ownedRelatedElement += FilterPackage )
;

MembershipImport :
	prefix = ImportPrefix membership=ImportedMembership
;

ImportedNamespace :
  // !TODO: Figure out why this breaks
  namespace = QualifiedName  !'::**' '::*'
;

ImportedMembership :
	importedMembership = QualifiedName ( '::' isRecursive ?= '**' )?
;



FilterPackage :
	ownedRelationship += FilterPackageImport
	( ownedRelationship += FilterPackageMember )+
;

FilterPackageImport :
	 FilterPackageMembershipImport | FilterPackageNamespaceImport
;

FilterPackageMembershipImport :
	ImportedMembership
;

FilterPackageNamespaceImport :
	ImportedNamespace
;

FilterPackageMember :
	visibility = FilterPackageMemberVisibility ownedRelatedElement += OwnedExpression ']'
;

 FilterPackageMemberVisibility :
	private = '['
;

 VisibilityIndicator :
	public = 'public' | private = 'private'| protected = 'protected'
;

/* Package Elements */

DefinitionElement :
	  ownedRelatedElement = Package
	| ownedRelatedElement = LibraryPackage
	| ownedRelatedElement = AnnotatingElement
	| ownedRelatedElement = Dependency
	| ownedRelatedElement = AttributeDefinition
	| ownedRelatedElement = EnumerationDefinition
	| ownedRelatedElement = OccurrenceDefinition
	| ownedRelatedElement = IndividualDefinition
	| ownedRelatedElement = ItemDefinition
	| ownedRelatedElement = MetadataDefinition
	| ownedRelatedElement = PartDefinition
	| ownedRelatedElement = ConnectionDefinition
	| ownedRelatedElement = FlowConnectionDefinition
	| ownedRelatedElement = InterfaceDefinition
	| ownedRelatedElement = AllocationDefinition
	| ownedRelatedElement = PortDefinition
	| ownedRelatedElement = ActionDefinition
	| ownedRelatedElement = CalculationDefinition
	| ownedRelatedElement = StateDefinition
	| ownedRelatedElement = ConstraintDefinition
	| ownedRelatedElement = RequirementDefinition
	| ownedRelatedElement = ConcernDefinition
	| ownedRelatedElement = CaseDefinition
	| ownedRelatedElement = AnalysisCaseDefinition
	| ownedRelatedElement = VerificationCaseDefinition
	| ownedRelatedElement = UseCaseDefinition
	| ownedRelatedElement = ViewDefinition
	| ownedRelatedElement = ViewpointDefinition
	| ownedRelatedElement = RenderingDefinition
	| ownedRelatedElement = ExtendedDefinition
;

UsageElement :
	  ownedRelatedElement = NonOccurrenceUsageElement
	| ownedRelatedElement = OccurrenceUsageElement
;

/* CLASSIFIERS */

/* Superclassing */

 SubclassificationPart :
	SpecializesKeyword ownedRelationship += OwnedSubclassification
	( ',' ownedRelationship += OwnedSubclassification )*
;

SpecializesKeyword :
	':>' | 'specializes'
;

OwnedSubclassification :
	superclassifier = QualifiedName
;

/* FEATURES */

/* Features */

 FeatureDeclaration :
	  identification=Identification specialization=FeatureSpecializationPart?
	| specialization=FeatureSpecializationPart
;

 FeatureSpecializationPart :
	  ( specialization+=FeatureSpecialization )+ multiplicity=MultiplicityPart? specialization2+=FeatureSpecialization*
	| multiplicity2=MultiplicityPart specialization+=FeatureSpecialization*
;

 MultiplicityPart :
	  ownedRelationship += OwnedMultiplicity
	| ( ownedRelationship += OwnedMultiplicity )?

( isOrdered ?= 'ordered' isNonunique ?= 'nonunique'
   | isNonunique2 ?= 'nonunique' isOrdered2 ?= 'ordered'
)

;

 FeatureSpecialization :
	ownedRelationship=Typings | ownedRelationship=Subsettings | ownedRelationship=References | ownedRelationship=Redefinitions
;

 Typings :
	typedby=TypedBy ( ',' ownedRelationship += FeatureTyping )*
;

 TypedBy :
	DefinedByKeyword ownedRelationship += FeatureTyping
;

DefinedByKeyword :
	':' | 'defined' 'by'
;

 Subsettings :
	SubsetsKeyword ownedRelationship += OwnedSubsetting[',']
;

/* Subsets :
	SubsetsKeyword ownedRelationship += OwnedSubsetting
;*/

SubsetsKeyword :
	':>' | 'subsets'
;

 References :
	ReferencesKeyword ownedRelationship += OwnedReferenceSubsetting
;

ReferencesKeyword :
	'::>' | 'references'
;

/*
Removing original redefinitions, because it requires two OwnedRedefinition
 Redefinitions :
	redefines=Redefines ownedRelationship += OwnedRedefinition[',']
;

 Redefines :
	RedefinesKeyword ownedRelationship += OwnedRedefinition
;*/

Redefinitions :
 redefines=RedefinesKeyword ownedRelationship += OwnedRedefinition[',']
;

RedefinesKeyword :
	':>>' | 'redefines'
;

/* Feature Typing, Subsetting and Redefinition */

FeatureTyping :
	ownedRelationship = OwnedFeatureTyping | ownedRelationship = ConjugatedPortTyping
;

// OwnedFeatureTyping inherited from Expression syntax.

OwnedSubsetting :
	  ownedRelatedElement += OwnedFeatureChain
	| subsettedFeature = QualifiedName
;

OwnedReferenceSubsetting :
	  ownedRelatedElement += OwnedFeatureChain
	| referencedFeature = QualifiedName
  // Always check for feature chain first.

;

OwnedRedefinition :
  redefinedFeature = QualifiedName
  | ownedRelatedElement += OwnedFeatureChain
;

/* Multiplicity */

OwnedMultiplicity :
	ownedRelatedElement += MultiplicityRange
;

MultiplicityRange :
	// TODO: Allow general expressions for bounds. (Causes LL parsing issues.)
	'[' ownedRelationship += MultiplicityExpressionMember
	      ( '..' ownedRelationship += MultiplicityExpressionMember )? ']'
;


MultiplicityRelatedElement :
    (ownedRelatedElement = LiteralExpression | ownedRelatedElement = FeatureReferenceExpression)
;

MultiplicityExpressionMember :
    ownedRelatedElement += MultiplicityRelatedElement
;

/* DEFINITION AND USAGE */

/* Definitions */

 BasicDefinitionPrefix :
	isAbstract ?= 'abstract' | isVariation ?= 'variation'
;

 DefinitionExtensionKeyword :
	ownedRelationship += PrefixMetadataMember
;

 DefinitionPrefix :
	prefix=BasicDefinitionPrefix? keyword+=DefinitionExtensionKeyword*
;

 Definition :
	declaration=DefinitionDeclaration body=DefinitionBody
;

 DefinitionDeclaration :
	identification=Identification? subclassificationpart=SubclassificationPart?
;

 DefinitionBody :
	';' | '{' ownedRelatedElement+=DefinitionBodyItem* '}'
;

 DefinitionBodyItem :
	  ownedRelationship += DefinitionMember
	| ownedRelationship += VariantUsageMember
	| ownedRelationship += NonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
	  ownedRelationship += OccurrenceUsageMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

DefinitionMember :
	prefix = MemberPrefix
	ownedRelatedElement += DefinitionElement
;

VariantUsageMember :
	MemberPrefix 'variant'
	ownedRelatedElement += VariantUsageElement
;

NonOccurrenceUsageMember :
	prefix=MemberPrefix ownedRelatedElement += NonOccurrenceUsageElement
;

OccurrenceUsageMember :
	prefix=MemberPrefix ownedRelatedElement += OccurrenceUsageElement
;

StructureUsageMember :
	prefix=MemberPrefix ownedRelatedElement += StructureUsageElement
;

BehaviorUsageMember :
	prefix=MemberPrefix ownedRelatedElement = BehaviorUsageElement
;

/* Usages */

 FeatureDirection :
	in = 'in ' | out = 'out' | inout = 'inout'
;

 RefPrefix :
	( direction = FeatureDirection )?
	( isAbstract ?= 'abstract' | isVariation ?= 'variation')?
	( isReadOnly ?= 'readonly' )?
	( isDerived ?= 'derived' )?
	( isEnd ?= 'end' )?
;

 BasicUsagePrefix :
	prefix=RefPrefix
	( isReference ?= 'ref' )?
;

 UsageExtensionKeyword :
	ownedRelationship += PrefixMetadataMember
;

 UsagePrefix :
	prefix=BasicUsagePrefix usageKeyword += UsageExtensionKeyword*
;

 Usage :
	declaration=UsageDeclaration? completion=UsageCompletion
;

 UsageDeclaration :
	  declaration=FeatureDeclaration
;

 UsageCompletion :
	valuepart=ValuePart? body=UsageBody
;

 UsageBody :
	body=DefinitionBody
;

 ValuePart :
	  ownedRelationship += FeatureValue
	| ownedRelationship += FeatureValueExpression
	  ownedRelationship += EmptyAssignmentActionMember
;

FeatureValue :
	( '=' | isDefault ?= 'default' ( isEqual ?= '=' | isInitial ?= ':=' )? )
	ownedRelatedElement = OwnedExpression
;

FeatureValueExpression :
	isInitial ?= ':='
	ownedRelatedElement += OwnedExpression
;

EmptyAssignmentActionMember :
	ownedRelatedElement += EmptyAssignmentAction
;

EmptyAssignmentAction :
	ownedRelationship += EmptyTargetMember
	ownedRelationship += EmptyParameterMember
;

EmptyTargetMember :
	ownedRelatedElement += EmptyTargetParameter
;

EmptyTargetParameter :
	ownedRelationship += TargetFeatureMember
;

/* Reference Usages */

ReferenceKeyword :
	'ref'
;

ReferenceUsageKeyword :
	ReferenceKeyword
;

DefaultReferenceUsage :
	prefix=RefPrefix declaration=UsageDeclaration valuepart=ValuePart? body=UsageBody
;

ReferenceUsage :
	prefix=RefPrefix ReferenceUsageKeyword usage=Usage
;

VariantReference :
	ownedRelationship += OwnedReferenceSubsetting
	FeatureSpecialization* UsageBody
;

/* Body Elements */

NonOccurrenceUsageElement :
	  ownedRelatedElement = DefaultReferenceUsage
	| ownedRelatedElement = ReferenceUsage
	| ownedRelatedElement = AttributeUsage
	| ownedRelatedElement = EnumerationUsage
	| ownedRelatedElement = BindingConnector
	| ownedRelatedElement = Succession
	| ownedRelatedElement = ExtendedUsage
;

OccurrenceUsageElement :
	ownedRelatedElement = StructureUsageElement | ownedRelatedElement = BehaviorUsageElement
;

StructureUsageElement :
	  ownedRelatedElement = OccurrenceUsage
	| ownedRelatedElement = IndividualUsage
	| ownedRelatedElement = PortionUsage
	| ownedRelatedElement = EventOccurrenceUsage
	| ownedRelatedElement = ItemUsage
	| ownedRelatedElement = PartUsage
	| ownedRelatedElement = ViewUsage
	| ownedRelatedElement = RenderingUsage
	| ownedRelatedElement = PortUsage
	| ownedRelatedElement = ConnectionUsage
	| ownedRelatedElement = InterfaceUsage
	| ownedRelatedElement = AllocationUsage
	| ownedRelatedElement = Message
	| ownedRelatedElement = FlowConnectionUsage
	| ownedRelatedElement = SuccessionFlowConnectionUsage
;

BehaviorUsageElement :
	  ownedRelationship = ActionUsage
	| ownedRelationship = CalculationUsage
	| ownedRelationship = StateUsage
	| ownedRelationship = ConstraintUsage
	| ownedRelationship = RequirementUsage
	| ownedRelationship = ConcernUsage
	| ownedRelationship = CaseUsage
	| ownedRelationship = AnalysisCaseUsage
	| ownedRelationship = VerificationCaseUsage
	| ownedRelationship = UseCaseUsage
	| ownedRelationship = ViewpointUsage
	| ownedRelationship = PerformActionUsage
	| ownedRelationship = ExhibitStateUsage
	| ownedRelationship = IncludeUseCaseUsage
	| ownedRelationship = AssertConstraintUsage
	| ownedRelationship = SatisfyRequirementUsage
;

VariantUsageElement :
	  VariantReference
	| ReferenceUsage
	| AttributeUsage
	| BindingConnector
	| Succession
	| OccurrenceUsage
	| IndividualUsage
	| PortionUsage
	| EventOccurrenceUsage
	| ItemUsage
	| PartUsage
	| ViewUsage
	| RenderingUsage
	| PortUsage
	| ConnectionUsage
	| InterfaceUsage
	| AllocationUsage
	| Message
	| FlowConnectionUsage
	| SuccessionFlowConnectionUsage
	| BehaviorUsageElement
;

/* EXTENSION */

ExtendedDefinition :
	BasicDefinitionPrefix? DefinitionExtensionKeyword+ 'def' Definition
;

ExtendedUsage :
	prefix=BasicUsagePrefix keyword+=UsageExtensionKeyword+ usage=Usage
;

/* ATTRIBUTES */

AttributeKeyword :
	'attribute'
;

AttributeDefKeyword :
	AttributeKeyword 'def'
;

AttributeUsageKeyword :
	AttributeKeyword
;

AttributeDefinition :
	prefix=DefinitionPrefix AttributeDefKeyword definition=Definition
;

AttributeUsage :
	prefix=UsagePrefix AttributeUsageKeyword usage=Usage
;

/* ENUMERATIONS */

EnumerationKeyword :
	'enum'
;
EnumerationDefKeyword :
	EnumerationKeyword 'def'
;

EnumerationUsageKeyword :
	EnumerationKeyword
;

EnumerationDefinition :
	EnumerationDefKeyword
  declaration=DefinitionDeclaration
  body=EnumerationBody
;

 EnumerationBody :
	  ';'
	| '{' ( ownedRelationship += AnnotatingMember
		  | ownedRelationship += EnumerationUsageMember
		  )*
	  '}'
;

EnumerationUsageMember :
	prefix=MemberPrefix ownedRelatedElement += EnumeratedValue
;

EnumeratedValue :
	keyword=EnumerationUsageKeyword? usage=Usage
;

EnumerationUsage :
	prefix=UsagePrefix EnumerationUsageKeyword usage=Usage
;

/* OCCURRENCES */

/* Occurrence Definitions */

OccurrenceKeyword :
	'occurrence'
;

OccurrenceDefKeyword :
	OccurrenceKeyword 'def'
;

 OccurrenceDefinitionPrefix :
	prefix=BasicDefinitionPrefix?
	( isIndividual ?= 'individual' ownedRelationship += LifeClassMembership )?
	keyword=DefinitionExtensionKeyword*
;

OccurrenceDefinition :
	OccurrenceDefinitionPrefix OccurrenceDefKeyword Definition
;

IndividualDefinition :
	BasicDefinitionPrefix? isIndividual ?= 'individual'
	DefinitionExtensionKeyword* 'def' Definition
	ownedRelationship += LifeClassMembership
;

LifeClassMembership :
	ownedRelatedElement += LifeClass
;

LifeClass ://This doesn't work.
	'lifeclass'
;

/* Occurrence Usages */

OccurrenceUsageKeyword :
	OccurrenceKeyword
;

 OccurrenceUsagePrefix :
	  prefix=BasicUsagePrefix
	  ( isIndividual ?= 'individual' )?
	  ( portionKind = PortionKind )?
	  usageExtension+=UsageExtensionKeyword*
;

OccurrenceUsage :
	prefix=OccurrenceUsagePrefix OccurrenceUsageKeyword usage=Usage
;

IndividualUsage :
	prefix=BasicUsagePrefix isIndividual ?= 'individual'
	usageExtension+=UsageExtensionKeyword* usage=Usage
;

PortionUsage :
	BasicUsagePrefix ( isIndividual ?= 'individual' )?
	portionKind = PortionKind
	UsageExtensionKeyword* Usage
;

 PortionKind :
	// Literal keywords identified explicitly so they can be found by syntax highlighting script
	snapshot = 'snapshot' | timeslice = 'timeslice'
;

EventOccurrenceUsage :
	 OccurrenceUsagePrefix 'event'
	( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
   	| OccurrenceUsageKeyword UsageDeclaration? )
    UsageCompletion
;

/* Occurrence Succession */

EmptySuccessionMember :
	ownedRelatedElement += EmptySuccession
;

EmptySuccession :
	'then' ownedRelationship += MultiplicitySourceEndMember
;

MultiplicitySourceEndMember :
	ownedRelatedElement += MultiplicitySourceEnd
;

MultiplicitySourceEnd :
	 ( ownedRelationship += OwnedMultiplicity )?
;

/* ITEMS */

ItemKeyword :
	'item'
;

ItemDefKeyword :
	ItemKeyword 'def'
;

ItemUsageKeyword :
	ItemKeyword
;

ItemDefinition :
	prefix=OccurrenceDefinitionPrefix ItemDefKeyword definition=Definition
;

ItemUsage :
	prefix=OccurrenceUsagePrefix ItemUsageKeyword usage=Usage
;

/* PARTS */

PartKeyword :
	'part'
;

PartDefKeyword :
	PartKeyword 'def'
;

PartUsageKeyword :
	PartKeyword
;

PartDefinition :
	prefix = OccurrenceDefinitionPrefix PartDefKeyword definition = Definition
;

PartUsage :
	prefix=OccurrenceUsagePrefix PartUsageKeyword usage=Usage
;

/* PORTS */

/* Port Definitions */

PortKeyword :
	'port'
;

PortDefKeyword :
	PortKeyword 'def'
;

PortDefinition :
	prefix=DefinitionPrefix PortDefKeyword definition=Definition
	//(ownedRelationship += ConjugatedPortDefinitionMember)
;

ConjugatedPortDefinitionMember :
	ownedRelatedElement += ConjugatedPortDefinition
;

ConjugatedPortDefinition :
	ownedRelationship += PortConjugation
;

PortConjugation ://This doesn't work.
	'portconjugation'
;

ConjugatedPortTyping :
	conjugatedPortDefinition = ConjugatedQualifiedName
;

ConjugatedQualifiedName :
	'~' QualifiedName
;

/* Port Usages */

PortUsageKeyword :
	PortKeyword
;

PortUsage :
	prefix=OccurrenceUsagePrefix PortUsageKeyword usage=Usage
;

/* CONNECTIONS */

/* Connectors */

ConnectorEndMember :
	ownedRelatedElement += ConnectorEnd
;

ConnectorEnd :
	( declaredName = Name ReferencesKeyword )?
	ownedRelationship += OwnedReferenceSubsetting
	( ownedRelationship += OwnedMultiplicity )?
;

/* Binding Connectors */

BindingKeyword :
	'binding'
;

BindingConnector :
	prefix=UsagePrefix ( BindingKeyword declaration=UsageDeclaration? )?
	'bind' ownedRelationship += ConnectorEndMember
	'=' ownedRelationship += ConnectorEndMember
	body=DefinitionBody
;

/* Successions */

SuccessionKeyword:
	'succession'
;

Succession :
	prefix=UsagePrefix ( SuccessionKeyword declaration=UsageDeclaration? )?
	'first' ownedRelationship += ConnectorEndMember
	'then' ownedRelationship += ConnectorEndMember
	body=DefinitionBody
;

/* Connection Definitions */

ConnectionKeyword :
	'connection'
;

ConnectionDefKeyword :
	ConnectionKeyword 'def'
;

ConnectionDefinition :
	prefix=OccurrenceDefinitionPrefix ConnectionDefKeyword definition=Definition
;

/* Connection Usages */

ConnectorKeyword :
	'connect'
;

ConnectionUsageKeyword :
	ConnectionKeyword
;

ConnectionUsage :
	prefix=OccurrenceUsagePrefix
	(
    ConnectionUsageKeyword declaration=UsageDeclaration? ( ConnectorKeyword part=ConnectorPart )?
  |
    ConnectorKeyword part=ConnectorPart
  )
  body=UsageBody
;

 ConnectorPart :
	part=BinaryConnectorPart | part=NaryConnectorPart
;

 BinaryConnectorPart :
	ownedRelationship += ConnectorEndMember 'to'
	ownedRelationship += ConnectorEndMember
;

 NaryConnectorPart :
	'(' ownedRelationship += ConnectorEndMember ','
	    ownedRelationship += ConnectorEndMember
	    ( ',' ownedRelationship += ConnectorEndMember )* ')'
;

EmptySourceEndMember :
	ownedRelatedElement += EmptySourceEnd
;

EmptySourceEnd ://This doesn't work.
	'emptysourceend'
;

/* FLOW CONNECTIONS */


/* Flow Connection Definitions */

FlowConnectionKeyword :
	'flow'
;

FlowConnectionDefKeyword :
	FlowConnectionKeyword 'def'
;

FlowConnectionDefinition :
	prefix=OccurrenceDefinitionPrefix FlowConnectionDefKeyword definition=Definition
;

/* Messages */

MessageKeyword :
	'message'
;

Message :
	OccurrenceUsagePrefix MessageKeyword MessageDeclaration DefinitionBody
;

 MessageDeclaration :
	  UsageDeclaration? ValuePart?
      ( 'of' ownedRelationship += ItemFeatureMember )?
      ( 'from' ownedRelationship += MessageEventMember
        'to' ownedRelationship += MessageEventMember
      )?
    | ownedRelationship += MessageEventMember 'to'
	  ownedRelationship += MessageEventMember
;

MessageEventMember :
	ownedRelatedElement += MessageEvent
;

MessageEvent :
	ownedRelationship += OwnedReferenceSubsetting
;

/* Flow Connection Usages */

FlowConnectionUsage :
	prefix=OccurrenceUsagePrefix FlowConnectionKeyword
	declaration=FlowConnectionDeclaration body=DefinitionBody
;

SuccessionFlowConnectionKeyword :
	SuccessionKeyword FlowConnectionKeyword
;

SuccessionFlowConnectionUsage :
	prefix=OccurrenceUsagePrefix SuccessionFlowConnectionKeyword
	declaration=FlowConnectionDeclaration body=DefinitionBody
;

 FlowConnectionDeclaration :
	  ownedRelationship_from = FlowEndMember 'to' ownedRelationship_to = FlowEndMember
    | declaration=UsageDeclaration? valuepart=ValuePart?
       ( 'of'  ownedRelationship_of = ItemFeatureMember )?
       ( 'from' ownedRelationship_from = FlowEndMember 'to' ownedRelationship_to = FlowEndMember )?
;

/* Flow Members */

ItemFeatureMember :
	ownedRelatedElement += ItemFeature
;

ItemFeature :
	  ownedRelatedElement = PayloadFeature
;

 PayloadFeature :
	  identification=Identification? pfsp=PayloadFeatureSpecializationPart valuepart=ValuePart?
	| identification=Identification? valuepart=ValuePart
    | ownedRelationship = OwnedFeatureTyping ( multiplicity2 = OwnedMultiplicity )?
    | multiplicity1 = OwnedMultiplicity ownedRelationship = OwnedFeatureTyping
;

 PayloadFeatureSpecializationPart :
	  (ownedRelationship+=FeatureSpecialization)+ mp=MultiplicityPart? ownedRelationship2+=FeatureSpecialization*
	| mp=MultiplicityPart ownedRelationship+=FeatureSpecialization+
;

FlowEndMember :
	ownedRelatedElement += FlowEnd
;

FlowEnd :
	( fes += FlowEndSubsetting )?
	ffm += FlowFeatureMember
;

FlowEndSubsetting :
	  ownedRelatedElement += FeatureChainPrefix
	| referencedFeature = QualifiedName '.'
;

FeatureChainPrefix :
  ( ownedRelationship += OwnedFeatureChaining '.' )+
  ownedRelationship += OwnedFeatureChaining '.'
;

FlowFeatureMember :
	ownedRelatedElement += FlowFeature
;

FlowFeature :
	ownedRelationship += FlowRedefinition
;

FlowRedefinition :
	redefinedFeature = QualifiedName
;

/* INTERFACES */

/* Interface Definitions */

InterfaceKeyword :
	'interface'
;

InterfaceDefKeyword :
	InterfaceKeyword 'def'
;

InterfaceDefinition :
	prefix=OccurrenceDefinitionPrefix InterfaceDefKeyword declaration=DefinitionDeclaration body=InterfaceBody
;

 InterfaceBody :
	';' | '{' item+=InterfaceBodyItem* '}'
;

 InterfaceBodyItem :
	  ownedRelationship += DefinitionMember
	| ownedRelationship += VariantUsageMember
	| ownedRelationship += InterfaceNonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
	  ownedRelationship += InterfaceOccurrenceUsageMember
	| ownedRelationship += AliasMember
	| ownedRelationship += Import
;

InterfaceNonOccurrenceUsageMember :
	MemberPrefix ownedRelatedElement += InterfaceNonOccurrenceUsageElement
;

InterfaceNonOccurrenceUsageElement :
	  ReferenceUsage
	| AttributeUsage
	| EnumerationUsage
	| BindingConnector
	| Succession
;

InterfaceOccurrenceUsageMember :
	prefix=MemberPrefix ownedRelatedElement += InterfaceOccurrenceUsageElement
;

InterfaceOccurrenceUsageElement :
	element=DefaultInterfaceEnd | element=StructureUsageElement | element=BehaviorUsageElement
;

DefaultInterfaceEnd :
	( direction = FeatureDirection )?
	( isAbstract ?= 'abstract' | isVariation ?= 'variation')?
	isEnd ?= 'end' usage=Usage
;

/* Interface Usages */

InterfaceUsageKeyword :
	InterfaceKeyword
;

InterfaceUsage :
	prefix=OccurrenceUsagePrefix InterfaceUsageKeyword declaration=InterfaceUsageDeclaration body=InterfaceBody
;

 InterfaceUsageDeclaration :
	declaration=UsageDeclaration? ( ConnectorKeyword part1=InterfacePart )? | part2=InterfacePart
;

 InterfacePart :
	binarypart=BinaryInterfacePart | narypart=NaryInterfacePart
;

 BinaryInterfacePart :
	ownedRelationship += InterfaceEndMember 'to'
	ownedRelationship += InterfaceEndMember
;

 NaryInterfacePart :
	'(' ownedRelationship += InterfaceEndMember ','
	    ownedRelationship += InterfaceEndMember
	    ( ',' ownedRelationship += InterfaceEndMember )* ')'
;

InterfaceEndMember :
	ownedRelatedElement = InterfaceEnd
;

InterfaceEnd :
	( declaredName = Name ReferencesKeyword )?
	ownedRelationship += OwnedReferenceSubsetting
	( ownedRelationship += OwnedMultiplicity )?
;

/* ALLOCATIONS */

/* Allocation Definitions */

AllocationKeyword :
	'allocation'
;

AllocationDefKeyword :
	AllocationKeyword 'def'
;

AllocationDefinition :
	OccurrenceDefinitionPrefix AllocationDefKeyword Definition
;

/* AllocationUsage Usages */

AllocationUsageKeyword :
	AllocationKeyword
;

AllocateKeyword :
	'allocate'
;

AllocationUsage :
	OccurrenceUsagePrefix AllocationUsageDeclaration UsageBody
;

 AllocationUsageDeclaration :
	    AllocationUsageKeyword UsageDeclaration? ( AllocateKeyword ConnectorPart )?
	  | AllocateKeyword ConnectorPart
;

/* ACTION */

/* Action Definitions */

ActionKeyword :
	'action'
;

ActionDefKeyword :
	ActionKeyword 'def'
;

ActionDefinition :
	prefix=OccurrenceDefinitionPrefix ActionDefKeyword declaration=DefinitionDeclaration body=ActionBody
;

 ActionBody :
	  ';'
	  // Note: Using a syntactic predicate here seems to avoid a possible infinite loop
	  // while incrementally parsing.
	| '{' items += ActionBodyItem* '}'
;


ActionBodyItemTarget :
    ( member=BehaviorUsageMember | member=ActionNodeMember )
;

ActionBodyItem :
	  ownedRelationship = Import
	| ownedRelationship = AliasMember
	| ownedRelationship = DefinitionMember
	| ownedRelationship = VariantUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship = StructureUsageMember
	| ownedRelationship = InitialNodeMember
	  ( target += TargetSuccessionMember )*
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship = ActionBodyItemTarget
	  ( target += TargetSuccessionMember )*
	| ownedRelationship = GuardedSuccessionMember
	| ownedRelationship = NonOccurrenceUsageMember
;


InitialNodeMember :
	MemberPrefix 'first' memberElement = QualifiedName
	RelationshipBody
;

ActionNodeMember :
	prefix=MemberPrefix ownedRelatedElement = ActionNode
;

TargetSuccessionMember :
	MemberPrefix ownedRelatedElement += ActionTargetSuccession
;

GuardedSuccessionMember :
	ownedRelatedElement += GuardedSuccession
;

/* Action Usages */

ActionUsageKeyword :
	ActionKeyword
;

ActionUsage :
	prefix=OccurrenceUsagePrefix ActionUsageKeyword declaration=ActionUsageDeclaration body=ActionBody
;

PerformActionUsage :
	prefix=OccurrenceUsagePrefix 'perform' declaration=PerformActionUsageDeclaration body=ActionBody
;

 PerformActionUsageDeclaration :
   	( ownedRelationship = OwnedReferenceSubsetting fspart=FeatureSpecializationPart?
   	| ActionUsageKeyword declaration=UsageDeclaration? )
    valuepart=ValuePart?
;

 ActionUsageDeclaration :
	  declaration=UsageDeclaration? valuepart=ValuePart?
;

/* Action Nodes */

ActionNode :
	  node=SendNode
  | node=AcceptNode
  | node=AssignmentNode
	| node=IfNode
  | node=WhileLoopNode
  | node=ForLoopNode
	| node=ControlNode
;

 ActionNodeUsageDeclaration :
	ActionUsageKeyword declaration=UsageDeclaration?
;

 ActionNodePrefix :
	OccurrenceUsagePrefix ActionNodeUsageDeclaration?
;

AcceptNode :
	prefix=OccurrenceUsagePrefix declaration=AcceptNodeDeclaration body=ActionBody
;

 AcceptNodeDeclaration :
	declaration=ActionNodeUsageDeclaration? 'accept' part=AcceptParameterPart
;

 AcceptParameterPart :
	ownedRelationship += PayloadParameterMember ('via' ownedRelationship += NodeParameterMember)?
;

PayloadParameterMember :
	ownedRelatedElement = PayloadParameter
;

PayloadParameter :
	  feature=PayloadFeature
	| identification=Identification? pfsp=PayloadFeatureSpecializationPart? tvp=TriggerValuePart
;

 TriggerValuePart :
	ownedRelationship = TriggerFeatureValue
;

TriggerFeatureValue :
	ownedRelatedElement = TriggerExpression
;

TriggerExpression :
	  kind = TimeTriggerKind
	  ownedRelationship = OwnedExpressionMember
	| ChangeTriggerKind
	  ownedRelationship = ChangeExpressionMember
;

TimeTriggerKind :
	isAt ?= 'at' | isAfter ?= 'after'
;

ChangeTriggerKind :
	'when'
;

ChangeExpressionMember :
	ownedRelatedElement = ChangeExpression
;

ChangeExpression :
	ownedRelationship = ChangeResultExpressionMember
;

ChangeResultExpressionMember :
	ownedRelatedElement = OwnedExpression
;


SendNode :
	OccurrenceUsagePrefix SendNodeDeclaration ActionBody
;

 SendNodeDeclaration :
	ActionNodeUsageDeclaration? 'send' ownedRelationship += NodeParameterMember
	( 'via' ownedRelationship += NodeParameterMember)
	( 'to' ownedRelationship += NodeParameterMember)
;

NodeParameterMember :
	ownedRelatedElement = NodeParameter
;

NodeParameter :
	 ownedRelationship = FeatureBinding
;

FeatureBinding :
	ownedRelatedElement = OwnedExpression
;

AssignmentNode :
	prefix=OccurrenceUsagePrefix declaration=AssignmentNodeDeclaration body=ActionBody
;

 AssignmentNodeDeclaration :
	declaration=ActionNodeUsageDeclaration? 'assign'
	ownedRelationship1 = FeatureChainMember ':='
	ownedRelationship2 = NodeParameterMember
;

TargetBinding :
	ownedRelatedElement += TargetExpression
;

TargetExpression :
	BaseExpression
	( (  '.'
	  ownedRelationship += FeatureChainMember
	  )?
	  (
	    operator = '[' operand += SequenceExpression ']'
	  |  '->'
	    ownedRelationship += ReferenceTyping
	    ( ownedRelationship += ExpressionBodyMember
	    | ownedRelationship += FunctionReferenceMember
	    | ArgumentList
	    )
	  |  '.'
	    ownedRelationship += ExpressionBodyMember
	  |  '.?'
	    ownedRelationship += ExpressionBodyMember
	  )
	)*
;

ExpressionParameterMember :
	ownedRelatedElement += OwnedExpression
;


IfNodeElseMember :
    ( ActionBodyParameterMember | IfNodeParameterMember )
;

IfNode :
	ActionNodePrefix
	'if' ownedRelationship += ExpressionParameterMember
	ownedRelationship += ActionBodyParameterMember
	( 'else' ownedRelationship += IfNodeElseMember )?
;


ActionBodyParameterMember :
	ownedRelatedElement += ActionBodyParameter
;

ActionBodyParameter :
	 ( ActionUsageKeyword UsageDeclaration? )? '{' items+=ActionBodyItem* '}'
;

IfNodeParameterMember :
	ownedRelatedElement += IfNode
;

WhileLoopNode :
	ActionNodePrefix
	( 'while' ownedRelationship += ExpressionParameterMember | 'loop')
	ownedRelationship += ActionBodyParameterMember
	( 'until' ownedRelationship += ExpressionParameterMember ';' )?
;

ForLoopNode :
	ActionNodePrefix
	'for' ownedRelationship += ForVariableDeclarationMember
	'in' ownedRelationship += NodeParameterMember
	ownedRelationship += ActionBodyParameterMember
;


ForVariableDeclarationMember :
	ownedRelatedElement += ForVariableDeclaration
;


ForVariableDeclaration :
	UsageDeclaration
;

ControlNode :
	  MergeNode
	| DecisionNode
	| JoinNode
	| ForkNode
;

 ControlNodePrefix :
	  RefPrefix
	  ( isIndividual ?= 'individual' )?
	  ( portionKind = PortionKind )?
;

MergeNode :
	ControlNodePrefix 'merge' UsageDeclaration?
	ActionNodeBody
;

DecisionNode :
	ControlNodePrefix 'decide' UsageDeclaration?
	ActionNodeBody
;

JoinNode :
	ControlNodePrefix 'join' UsageDeclaration?
	ActionNodeBody
;

ForkNode :
	ControlNodePrefix 'fork' UsageDeclaration?
	ActionNodeBody
;

 ActionNodeBody :
	';' | '{' ( ownedRelationship += AnnotatingMember )* '}'
;

/* Action Succession */

ActionTargetSuccession :
	( TargetSuccession | GuardedTargetSuccession | DefaultTargetSuccession )
	UsageBody
;

TargetSuccession :
	'then' ownedRelationship += MultiplicitySourceEndMember
	ownedRelationship += ConnectorEndMember
;

GuardedTargetSuccession :
	ownedRelationship += GuardExpressionMember
	'then' ownedRelationship += TransitionSuccessionMember
;

DefaultTargetSuccession :
	'else' ownedRelationship += TransitionSuccessionMember
;

GuardedSuccession :
// first if then
	( SuccessionKeyword UsageDeclaration )? 'first'
	ownedRelationship += TransitionSourceMember
	ownedRelationship += GuardExpressionMember
	'then' ownedRelationship += TransitionSuccessionMember
	UsageBody
;

/* STATES */

/* State Definitions */

StateKeyword :
	'state'
;

StateDefKeyword :
	StateKeyword 'def'
;

StateDefinition :
	prefix=OccurrenceDefinitionPrefix StateDefKeyword declaration=DefinitionDeclaration body=StateDefBody
;

StateDefBody :
	';' | ( isParallel ?= 'parallel' )? '{' part=StateBodyPart '}'
;

 StateBodyPart :
	// Note: Using a syntactic predicate here seems to avoid a possible infinite loop
	// while incrementally parsing.
 item+=StateBodyItem*
;

 StateBodyItem :
	  ownedRelationship = Import
	| ownedRelationship = AliasMember
	| ownedRelationship = DefinitionMember
	| ownedRelationship = VariantUsageMember
	| ownedRelationship = NonOccurrenceUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship += StructureUsageMember
	| ( ownedRelationship += EmptySuccessionMember )?
    ownedRelationship += BehaviorUsageMember
	  ( ownedRelationship += TargetTransitionUsageMember )*
	| ownedRelationship = TransitionUsageMember
	| ownedRelationship += EntryActionMember
	  ( ownedRelationship += EntryTransitionMember )*
	| ownedRelationship = DoActionMember
	| ownedRelationship = ExitActionMember
;

EntryActionMember :
	prefix=MemberPrefix EntryActionKind ownedRelatedElement=StateActionUsage
;

EntryActionKind :
	'entry'
;

DoActionMember :
	prefix=MemberPrefix DoActionKind ownedRelatedElement=StateActionUsage
;

DoActionKind :
	'do'
;

ExitActionMember :
	prefix=MemberPrefix ExitActionKind ownedRelatedElement=StateActionUsage
;

ExitActionKind :
	'exit'
;

EntryTransitionMember :
	prefix=MemberPrefix
	( ownedRelatedElement=GuardedTargetSuccession
	| 'then' ownedRelatedElement=TransitionSuccession
	) ';'
;

StateActionUsage :
	';' | pau=PerformedActionUsage body=ActionBody
;

PerformedActionUsage :
	   declaration=PerformActionUsageDeclaration
	|  declaration=AcceptNodeDeclaration
	|  declaration=SendNodeDeclaration
	|  declaration=AssignmentNodeDeclaration
;

TransitionUsageMember :
	prefix=MemberPrefix ownedRelatedElement=TransitionUsage
;

TargetTransitionUsageMember :
	prefix=MemberPrefix ownedRelatedElement=TargetTransitionUsage
;

/* State Usages */

StateUsageKeyword :
	StateKeyword
;

StateUsage :
	prefix=OccurrenceUsagePrefix StateUsageKeyword declaration=ActionUsageDeclaration body=StateUsageBody
;

 StateUsageBody :
	body=StateDefBody
;

ExhibitStateUsage :
    OccurrenceUsagePrefix 'exhibit'
    ( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
    | StateUsageKeyword UsageDeclaration?
    )
    ValuePart? StateUsageBody
;

/* Transition Usages */

TransitionUsageKeyword :
	'transition'
;

TransitionUsage :
	TransitionUsageKeyword ( declaration=UsageDeclaration? 'first' )?
	ownedRelationship += TransitionSourceMember
	( ownedRelationship += TriggerActionMember )?
	( ownedRelationship += GuardExpressionMember )?
	( ownedRelationship += EffectBehaviorMember )?
	'then' ownedRelationship += TransitionSuccessionMember
	body=ActionBody
;

TargetTransitionUsage :
	TransitionUsageKeyword?
	((
    (ownedRelationship1 = TriggerActionMember)
	  (ownedRelationship2 = GuardExpressionMember)?
	  (ownedRelationship3 = EffectBehaviorMember)?
  ) | (
    (ownedRelationship2 = GuardExpressionMember)
    (ownedRelationship3 = EffectBehaviorMember)?
  ) | (
    (ownedRelationship3 = EffectBehaviorMember)
  ))
	'then' ownedRelationship4 = TransitionSuccessionMember
	body=ActionBody
;

TransitionSourceMember :
	  ownedRelatedElement += OwnedFeatureChain
	| memberElement = QualifiedName
;

TriggerActionMember :
	TriggerFeatureKind ownedRelatedElement=TriggerAction
;

 TriggerFeatureKind :
	trigger = 'accept'
;

TriggerAction :
	part=AcceptParameterPart
;

GuardExpressionMember :
	GuardFeatureKind ownedRelatedElement=OwnedExpression
;

 GuardFeatureKind :
	guard = 'if'
;

EffectBehaviorMember :
	EffectFeatureKind ownedRelatedElement=EffectBehaviorUsage
;

 EffectFeatureKind :
	effect = 'do'
;

EffectBehaviorUsage :
	  usage=PerformedActionUsage ( '{' item+=ActionBodyItem* '}' )?
;

TransitionSuccessionMember :
	ownedRelatedElement = TransitionSuccession
;

TransitionSuccession :
	ownedRelationship = ConnectorEndMember
;

/* CALCULATIONS */

/* Calculation Definitions */

CalculationKeyword :
	'calc'
;

CalculationDefKeyword :
	CalculationKeyword 'def'
;

CalculationDefinition :
	prefix=OccurrenceDefinitionPrefix CalculationDefKeyword declaration=DefinitionDeclaration
	body=CalculationBody
;

 CalculationBody :
	';' | '{' part+=CalculationBodyPart '}'
;

 CalculationBodyPart :
 item += CalculationBodyItem*
	( ownedRelationship += ResultExpressionMember )?
;

 CalculationBodyItem :
	  item = ActionBodyItem
	| ownedRelationship = ReturnParameterMember
;

ReturnParameterMember :
	prefix=MemberPrefix 'return' ownedRelatedElement=UsageElement
;

ResultExpressionMember :
	prefix=MemberPrefix ownedRelatedElement=OwnedExpression
;

/* Calculation Usages */

CalculationUsageKeyword :
	CalculationKeyword
;

CalculationUsage :
	prefix=OccurrenceUsagePrefix CalculationUsageKeyword declaration=CalculationUsageDeclaration body=CalculationBody
;

 CalculationUsageDeclaration :
	  declaration=UsageDeclaration? valuepart=ValuePart?
;

/* CONSTRAINTS */

/* Constraint Definitions */

ConstraintKeyword :
	'constraint'
;

ConstraintDefKeyword :
	ConstraintKeyword 'def'
;

ConstraintDefinition :
	prefix=OccurrenceDefinitionPrefix ConstraintDefKeyword declaration=DefinitionDeclaration body=CalculationBody
;

/* Constraint Usages */

ConstraintUsageKeyword :
	ConstraintKeyword
;

ConstraintUsage :
	prefix=OccurrenceUsagePrefix ConstraintUsageKeyword declaration=CalculationUsageDeclaration body=CalculationBody
;

AssertConstraintUsage :
	prefix=OccurrenceUsagePrefix 'assert' ( isNegated ?= 'not' )?
    ( ownedRelationship += OwnedReferenceSubsetting featurespecializationpart=FeatureSpecializationPart?
    | ConstraintUsageKeyword declaration=UsageDeclaration?
    )
    body=CalculationBody
;

/* REQUIREMENTS */

/* Requirement Definitions */

RequirementKeyword :
	'requirement'
;

RequirementDefKeyword :
	RequirementKeyword 'def'
;

RequirementDefinition :
	prefix=OccurrenceDefinitionPrefix RequirementDefKeyword declaration=DefinitionDeclaration body=RequirementBody
;

 RequirementBody :
	  ';' | '{' item+=RequirementBodyItem* '}'
;

 RequirementBodyItem :
	  ownedRelationship = DefinitionBodyItem
	| ownedRelationship = SubjectMember
	| ownedRelationship = RequirementConstraintMember
	| ownedRelationship = FramedConcernMember
	| ownedRelationship = RequirementVerificationMember
	| ownedRelationship = ActorMember
	| ownedRelationship = StakeholderMember
;

SubjectMember :
	prefix=MemberPrefix ownedRelatedElement = SubjectUsage
;

SubjectUsage :
	'subject' keyword+=UsageExtensionKeyword* usage=Usage
;

RequirementConstraintMember :
	prefix=MemberPrefix kind = RequirementConstraintKind
	ownedRelatedElement = RequirementConstraintUsage
;

 RequirementConstraintKind :
	assumption = 'assume' | requirement = 'require'
;

RequirementConstraintUsage :
    (
      ownedRelationship = OwnedReferenceSubsetting fs+=FeatureSpecialization*
      body=RequirementBody
    )
    |
    (
      (
        keyword1+=UsageExtensionKeyword* ConstraintUsageKeyword
        |
        keyword2+=UsageExtensionKeyword+
      )
      declaration=CalculationUsageDeclaration body=CalculationBody
    )
;

FramedConcernMember :
	MemberPrefix kind = FramedConcernKind
	ownedRelatedElement += FramedConcernUsage
;

 FramedConcernKind :
	requirement = 'frame'
;

FramedConcernUsage :
      ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization*
      RequirementBody
    | ( UsageExtensionKeyword* ConcernUsageKeyword | UsageExtensionKeyword+ )
      CalculationUsageDeclaration CalculationBody
;

ActorMember :
	MemberPrefix
	ownedRelatedElement += ActorUsage
;

ActorUsage :
      'actor' UsageExtensionKeyword* Usage
;

StakeholderMember :
	MemberPrefix
	ownedRelatedElement += StakeholderUsage
;

StakeholderUsage :
      'stakeholder' UsageExtensionKeyword* Usage
;

/* Requirement Usages */

RequirementUsageKeyword :
	RequirementKeyword
;

RequirementUsage :
	prefix=OccurrenceUsagePrefix RequirementUsageKeyword declaration=CalculationUsageDeclaration body=RequirementBody
;

SatisfyRequirementUsage :
	prefix=OccurrenceUsagePrefix (isAssert ?= 'assert')? ( isNegated ?= 'not' )? 'satisfy'
	( ors = OwnedReferenceSubsetting fsp=FeatureSpecializationPart?
    | RequirementUsageKeyword declaration=UsageDeclaration?
  )
  valuepart=ValuePart? ( 'by' ssm = SatisfactionSubjectMember )?
  body=RequirementBody
;

SatisfactionSubjectMember :
	ownedRelatedElement = SatisfactionParameter
;

SatisfactionParameter :
	ownedRelationship = SatisfactionFeatureValue
;

SatisfactionFeatureValue :
	ownedRelatedElement = SatisfactionReferenceExpression
;

SatisfactionReferenceExpression :
	ownedRelationship = FeatureChainMember
;

/* CONCERNS */

/* Concern Definitions */

ConcernKeyword :
	'concern'
;

ConcernDefKeyword :
	ConcernKeyword 'def'
;

ConcernDefinition :
	OccurrenceDefinitionPrefix ConcernDefKeyword DefinitionDeclaration RequirementBody
;

ConcernUsageKeyword :
	ConcernKeyword
;

ConcernUsage :
	OccurrenceUsagePrefix ConcernUsageKeyword CalculationUsageDeclaration RequirementBody
;

/* CASES */

/* Case Definitions */

CaseKeyword :
	'case'
;

CaseDefKeyword :
	CaseKeyword 'def'
;

CaseDefinition :
	OccurrenceDefinitionPrefix CaseDefKeyword DefinitionDeclaration CaseBody
;

 CaseBody :
	    ';'
	  | '{' item+=CaseBodyItem* ( ownedRelationship = ResultExpressionMember )?
	    '}'
;

 CaseBodyItem :
	  ownedRelationship = CalculationBodyItem
	| ownedRelationship = SubjectMember
	| ownedRelationship = ActorMember
	| ownedRelationship = ObjectiveMember
;

ObjectiveMember :
	prefix=MemberPrefix 'objective' ownedRelatedElement=ObjectiveRequirementUsage
;

ObjectiveRequirementUsage :
	keyword+=UsageExtensionKeyword* declaration=CalculationUsageDeclaration body=RequirementBody
;

/* Case Usages */

CaseUsageKeyword :
	CaseKeyword
;

CaseUsage :
	OccurrenceUsagePrefix CaseUsageKeyword CalculationUsageDeclaration CaseBody
;

/* ANALYSIS CASES */

AnalysisCaseKeyword :
	'analysis'
;

AnalysisCaseDefKeyword :
	AnalysisCaseKeyword 'def'
;

AnalysisCaseUsageKeyword :
	AnalysisCaseKeyword
;

AnalysisCaseDefinition :
	prefix=OccurrenceDefinitionPrefix AnalysisCaseDefKeyword
  declaration=DefinitionDeclaration body=CaseBody
;

AnalysisCaseUsage :
	prefix=OccurrenceUsagePrefix AnalysisCaseUsageKeyword
  declaration=CalculationUsageDeclaration body=CaseBody
;

/* VERIFICATION CASES */

VerificationCaseKeyword :
	'verification'
;

VerificationCaseDefKeyword :
	VerificationCaseKeyword 'def'
;

VerificationCaseUsageKeyword :
	VerificationCaseKeyword
;

VerificationCaseDefinition :
	OccurrenceDefinitionPrefix VerificationCaseDefKeyword DefinitionDeclaration CaseBody
;

VerificationCaseUsage :
	OccurrenceUsagePrefix VerificationCaseUsageKeyword CalculationUsageDeclaration CaseBody
;

RequirementVerificationMember :
	MemberPrefix kind = RequirementVerificationKind
	ownedRelatedElement += RequirementVerificationUsage
;

 RequirementVerificationKind :
	requirement = 'verify'
;

RequirementVerificationUsage :
      ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization*
      RequirementBody
    | ( UsageExtensionKeyword* RequirementUsageKeyword | UsageExtensionKeyword+ )
      CalculationUsageDeclaration RequirementBody
;

/* USE CASES */

UseCaseKeyword :
	'use' 'case'
;

UseCaseDefKeyword :
	UseCaseKeyword 'def'
;

UseCaseUsageKeyword :
	UseCaseKeyword
;

UseCaseDefinition :
	OccurrenceDefinitionPrefix UseCaseDefKeyword DefinitionDeclaration CaseBody
;

UseCaseUsage :
	OccurrenceUsagePrefix UseCaseUsageKeyword CalculationUsageDeclaration CaseBody
;

IncludeUseCaseUsage :
	OccurrenceUsagePrefix 'include'
   	( ownedRelationship += OwnedReferenceSubsetting FeatureSpecializationPart?
   	| UseCaseUsageKeyword UsageDeclaration? )
    ValuePart?
	CaseBody
;

/* VIEWS */

/* View Definitions */

ViewKeyword :
	'view'
;

ViewDefKeyword :
	ViewKeyword 'def'
;

ViewDefinition :
	OccurrenceDefinitionPrefix ViewDefKeyword DefinitionDeclaration ViewDefinitionBody
;

 ViewDefinitionBody :
	  ';'
	| '{' ViewDefinitionBodyItem* '}'
;

 ViewDefinitionBodyItem :
	  DefinitionBodyItem
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += ViewRenderingMember
;

ViewRenderingMember :
	MemberPrefix 'render'
	ownedRelatedElement += ViewRenderingUsage
;

ViewRenderingUsage :
	 ownedRelationship += OwnedReferenceSubsetting FeatureSpecialization* UsageBody
;

/* View Usages */

ViewUsageKeyword :
	ViewKeyword
;

ViewUsage :
	OccurrenceUsagePrefix ViewUsageKeyword UsageDeclaration? ValuePart? ViewBody
;

 ViewBody :
	';' | '{' ViewBodyItem* '}'
;

 ViewBodyItem :
	  DefinitionBodyItem
	| ownedRelationship += ElementFilterMember
	| ownedRelationship += Expose
	| ownedRelationship += ViewRenderingMember
;

Expose :
	( MembershipExpose | NamespaceExpose )
	RelationshipBody
;

MembershipExpose :
	( visibility = VisibilityIndicator )?
	'expose' ImportedMembership
;

NamespaceExpose :
	( visibility = VisibilityIndicator )?
	'expose'
	( ImportedNamespace
	| ownedRelatedElement += FilterPackage
	)
;

/* VIEWPOINTS */

ViewpointKeyword :
	'viewpoint'
;

ViewpointDefKeyword :
	ViewpointKeyword 'def'
;

ViewpointUsageKeyword :
	ViewpointKeyword
;

ViewpointDefinition :
	OccurrenceDefinitionPrefix ViewpointDefKeyword DefinitionDeclaration RequirementBody
;

ViewpointUsage :
	OccurrenceUsagePrefix ViewpointUsageKeyword CalculationUsageDeclaration RequirementBody
;

/* RENDERINGS */

RenderingKeyword :
	'rendering'
;

RenderingDefKeyword :
	RenderingKeyword 'def'
;

RenderingDefinition :
	OccurrenceDefinitionPrefix RenderingDefKeyword Definition
;

RenderingUsageKeyword :
	RenderingKeyword
;

RenderingUsage :
	OccurrenceUsagePrefix RenderingUsageKeyword Usage
;

/* EXPRESSIONS */

ExpressionBody :
	body=CalculationBody
;
